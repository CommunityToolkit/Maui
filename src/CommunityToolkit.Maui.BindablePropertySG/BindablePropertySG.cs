using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Text;
using CommunityToolkit.Maui.BindablePropertySG.Helpers;
using CommunityToolkit.Maui.BindablePropertySG.Models;
using CommunityToolkit.Maui.SourceGenerators.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CommunityToolkit.Maui.BindablePropertySG;

[Generator]
public class BindablePropertySG : IIncrementalGenerator
{
	static readonly SemanticValues emptySemanticValues = new(default, Array.Empty<BPInfo>().ToImmutableArray());

	const string bpFullName = "global::Microsoft.Maui.Controls.BindableProperty";
	const string bindingModeFullName = "global::Microsoft.Maui.Controls.";

	const string bpAttribute = """
#nullable enable
namespace CommunityToolkit.Maui.BindablePropertySG;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
public sealed class BindablePropertyAttribute<TReturnType> : Attribute
{
	public string PropertyName { get; } = string.Empty;
	public Type? OwnerType { get; set; }
	public object? DefaultValue { get; set; }
	public string DefaultBindingMode { get; set; } = string.Empty;
	public string ValidateValueMethodName { get; set; } = string.Empty;
	public string PropertyChangedMethodName { get; set; } = string.Empty;
	public string PropertyChangingMethodName { get; set; } = string.Empty;
	public string CoerceValueMethodName { get; set; } = string.Empty;
	public string DefaultValueCreatorMethodName { get; set; } = string.Empty;

	public BindablePropertyAttribute(string propertyName)
	{
		PropertyName = propertyName;
	}
}
""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource("BindablePropertyAttribute.g.cs", SourceText.From(bpAttribute, Encoding.UTF8)));

		var provider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.BindablePropertySG.BindablePropertyAttribute`1",
			SyntaxPredicate, SemanticTransform)
			.Where(static x => x.ClassInformation != default || !x.BPInfos.IsEmpty)
			.Collect()
			.SelectMany(static (types, _) => types);


		context.RegisterSourceOutput(provider, Execute);
	}

	void Execute(SourceProductionContext context, SemanticValues semanticValues)
	{
		var source = GenerateSource(semanticValues);
		SourceStringService.FormatText(ref source);
		context.AddSource($"{semanticValues.ClassInformation.ClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
	}

	static string GenerateSource(SemanticValues value)
	{
		var sb = new StringBuilder($@"
// <auto-generated>
// Test2 : {DateTime.Now}

namespace {value.ClassInformation.ContainingNamespace};

{value.ClassInformation.DeclaredAccessibility} partial class {value.ClassInformation.ClassName}
{{
");

		foreach (var info in value.BPInfos)
		{
			GenerateBindableProperty(sb, info);
			GenerateProperty(sb, info);
		}

		sb.AppendLine().Append("}");
		return sb.ToString();

		static void GenerateBindableProperty(StringBuilder sb, BPInfo info)
		{
			/// <summary>
			/// Backing BindableProperty for the <see cref="PropertyName"/> property.
			/// </summary>
			sb.AppendLine("/// <summary>")
				.AppendLine($"/// Backing BindableProperty for the <see cref=\"{info.PropertyName}\"/> property.")
				.AppendLine("/// </summary>");
			
			// public static readonly BindableProperty TextProperty = BindableProperty.Create(...);
			sb.AppendLine($"public static readonly {bpFullName} {info.PropertyName}Property = ")
							.Append($"{bpFullName}.Create(")
							.Append($"\"{info.PropertyName}\", ")
							.Append($"typeof({info.ReturnType}), ")
							.Append($"typeof({info.DeclaringType}), ")
							.Append($"{info.DefaultValue}, ")
							.Append($"{bindingModeFullName}{info.DefaultBindingMode}, ")
							.Append($"{info.ValidateValueMethodName}, ")
							.Append($"{info.PropertyChangedMethodName}, ")
							.Append($"{info.PropertyChangingMethodName}, ")
							.Append($"{info.CoerceValueMethodName}, ")
							.Append($"{info.DefaultValueCreatorMethodName}")
							.Append(");");

			sb.AppendLine().AppendLine();
		}

		static void GenerateProperty(StringBuilder sb, BPInfo info)
		{

			/// <inheritdoc />
			sb.AppendLine("/// <inheritdoc />");
			
			//public string Text
			//{
			//	get => (string)GetValue(TextProperty);
			//	set => SetValue(TextProperty, value);
			//}
			sb.AppendLine($"public {info.ReturnType} {info.PropertyName}")
							.AppendLine("{")
							.Append("get => (")
							.Append(info.ReturnType)
							.Append(")GetValue(")
							.AppendLine($"{info.PropertyName}Property);")
							.Append("set => SetValue(")
							.AppendLine($"{info.PropertyName}Property, value);")
							.AppendLine("}");
		}
	}

	static SemanticValues SemanticTransform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var @class = Unsafe.As<ClassDeclarationSyntax>(context.TargetNode);
		var semanticModel = context.SemanticModel;
		var classSymbol = (ITypeSymbol?)semanticModel.GetDeclaredSymbol(@class, cancellationToken);

		if (classSymbol is null)
		{
			return emptySemanticValues;
		}

		var classInfo = new ClassInformation(classSymbol.Name, classSymbol.DeclaredAccessibility.ToString().ToLower(), classSymbol.ContainingNamespace.ToDisplayString());


		var bpInfos = new List<BPInfo>(context.Attributes.Length);

		foreach (var attributeData in context.Attributes)
		{
			bpInfos.Add(GetAttributeValues(attributeData, classSymbol?.ToString() ?? string.Empty));
		}

		return new(classInfo, bpInfos.ToImmutableArray());
	}

	static BPInfo GetAttributeValues(in AttributeData attributeData, in string declaringTypeString)
	{
		_ = attributeData.AttributeClass ?? throw new NullReferenceException(nameof(attributeData.AttributeClass));
		var bpType = attributeData.AttributeClass.TypeArguments[0];
		var defaultValue = attributeData.GetNamedArgumentsAttributeValueByNameAsString("DefaultValue");
		var coerceValueMethodName = attributeData.GetNamedArgumentsAttributeValueByNameAsString("CoerceValueMethodName");
		var defaultBindingMode = attributeData.GetNamedArgumentsAttributeValueByNameAsString("DefaultBindingMode", "BindingMode.OneWay");
		var defaultValueCreatorMethodName = attributeData.GetNamedArgumentsAttributeValueByNameAsString("DefaultValueCreatorMethodName");
		var declaringType = attributeData.GetNamedArgumentsAttributeValueByNameAsString("OwnerType", declaringTypeString);
		var propertyChangedMethodName = attributeData.GetNamedArgumentsAttributeValueByNameAsString("PropertyChangedMethodName");
		var propertyChangingMethodName = attributeData.GetNamedArgumentsAttributeValueByNameAsString("PropertyChangingMethodName");
		var propertyName = attributeData.GetConstructorArgumentsAttributeValueByNameAsString();
		var validateValueMethodName = attributeData.GetNamedArgumentsAttributeValueByNameAsString("ValidateValueMethodName");

		return new BPInfo
		{
			CoerceValueMethodName = coerceValueMethodName,
			DefaultBindingMode = defaultBindingMode,
			DefaultValue = defaultValue,
			DefaultValueCreatorMethodName = defaultValueCreatorMethodName,
			DeclaringType = declaringType,
			PropertyChangedMethodName = propertyChangedMethodName,
			PropertyChangingMethodName = propertyChangingMethodName,
			PropertyName = propertyName,
			ReturnType = bpType,
			ValidateValueMethodName = validateValueMethodName
		};
	}

	static bool SyntaxPredicate(SyntaxNode node, CancellationToken cancellationToken) =>
		node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
}
