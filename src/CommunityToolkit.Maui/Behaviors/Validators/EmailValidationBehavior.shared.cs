using System.Globalization;
using System.Net.Mail;
using System.Text.RegularExpressions;

namespace CommunityToolkit.Maui.Behaviors;

/// <summary>
/// The <see cref="EmailValidationBehavior"/> is a behavior that allows users to determine whether or not text input is a valid e-mail address. 
/// For example, an <see cref="Entry"/> control can be styled differently depending on whether a valid or an invalid e-mail address is provided.
/// The validation is achieved through a regular expression that is used to verify whether or not the text input is a valid e-mail address.
/// It can be overridden to customize the validation through the properties it inherits from <see cref="ValidationBehavior"/>.
/// </summary>
public partial class EmailValidationBehavior : TextValidationBehavior
{
	/// <summary>
	/// A <see cref="Regex"/> to verify an input is a valid IPv4 address
	/// Generated by <see cref="GeneratedRegexAttribute"/>
	/// </summary>
	/// <returns>Generated <see cref="Regex"/></returns>
	[GeneratedRegex("^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$", RegexOptions.None, 250)]
	protected static partial Regex Ipv4Regex();

	/// <summary>
	/// A <see cref="Regex"/> to verify an input only contains hexidecimal characters
	/// Generated by <see cref="GeneratedRegexAttribute"/>
	/// </summary>
	/// <returns>Generated <see cref="Regex"/></returns>
	[GeneratedRegex(@"\A\b[0-9a-fA-F]+\b\Z", RegexOptions.None, 250)]
	protected static partial Regex HexadecimalRegex();

	/// <summary>
	/// A <see cref="Regex"/> to verify an input is a valid IPv6 address
	/// Generated by <see cref="GeneratedRegexAttribute"/>
	/// </summary>
	/// <returns>Generated <see cref="Regex"/></returns>
	[GeneratedRegex("^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$", RegexOptions.None, 250)]
	protected static partial Regex Ipv6Regex();

	/// <summary>
	/// A <see cref="Regex"/> to verify an input is a valid email address
	/// Generated by <see cref="GeneratedRegexAttribute"/>
	/// </summary>
	/// <returns>Generated <see cref="Regex"/></returns>
	[GeneratedRegex(@"^[^@\s]+@[^@\s]+\.[^@\s]+$", RegexOptions.IgnoreCase, 250)]
	protected static partial Regex EmailRegex();

	/// <summary>
	/// A <see cref="Regex"/> to normalize an input a domain
	/// Generated by <see cref="GeneratedRegexAttribute"/>
	/// </summary>
	/// <returns>Generated <see cref="Regex"/></returns>
	[GeneratedRegex(@"(@)(.+)$", RegexOptions.None, 250)]
	protected static partial Regex EmailDomainRegex();

	/// <summary>
	/// Examines the domain part of the email and normalizes it to ASCII
	/// </summary>
	/// <param name="match"></param>
	/// <returns></returns>
	/// <exception cref="ArgumentException"></exception>
	private protected static string DomainMapper(Match match)
	{
		// Use IdnMapping class to convert Unicode domain names.
		var idn = new IdnMapping();

		if (match.Groups[2].Value.StartsWith('-'))
		{
			throw new ArgumentException("Domain name cannot start with hyphen.");
		}

		// Pull out and process domain name (throws ArgumentException on invalid)
		string domainName = idn.GetAscii(match.Groups[2].Value);

		if (domainName.All(x => char.IsDigit(x) || x is '.')
			&& !Ipv4Regex().IsMatch(domainName))
		{
			throw new ArgumentException("Invalid IPv4 Address.");
		}

		if (HexadecimalRegex().IsMatch(domainName)
			&& !Ipv6Regex().IsMatch(domainName))
		{
			throw new ArgumentException("Invalid IPv6 Address.");
		}

		return match.Groups[1].Value + domainName;
	}

	/// <inheritdoc /> 
	protected override async ValueTask<bool> ValidateAsync(string? value, CancellationToken token)
	{
		return IsValidEmail(value) && await base.ValidateAsync(value, token);
	}

	/// <inheritdoc /> 
	protected override void OnAttachedTo(VisualElement bindable)
	{
		// Assign Keyboard.Email if the user has not specified a specific Keyboard layout
		if (bindable is InputView inputView && inputView.Keyboard == Keyboard.Default)
		{
			inputView.Keyboard = Keyboard.Email;
		}

		base.OnAttachedTo(bindable);
	}

	/// <inheritdoc /> 
	protected override void OnDetachingFrom(VisualElement bindable)
	{
		// Assign Keyboard.Default if the user has not specified a different Keyboard layout
		if (bindable is InputView inputView && inputView.Keyboard == Keyboard.Email)
		{
			inputView.Keyboard = Keyboard.Default;
		}

		base.OnDetachingFrom(bindable);
	}

	// https://docs.microsoft.com/dotnet/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format
	static bool IsValidEmail(string? email)
	{
		if (string.IsNullOrWhiteSpace(email)
			|| email.StartsWith('.')
			|| email.Contains("..", StringComparison.Ordinal)
			|| email.Contains(".@", StringComparison.Ordinal))
		{
			return false;
		}

		try
		{
			// Normalize the domain
			email = EmailDomainRegex().Replace(email, DomainMapper);
		}
		catch (RegexMatchTimeoutException)
		{
			return false;
		}
		catch (ArgumentException)
		{
			return false;
		}

		try
		{
			return EmailRegex().IsMatch(email) && MailAddress.TryCreate(email, out _);
		}
		catch (RegexMatchTimeoutException)
		{
			return false;
		}
	}
}