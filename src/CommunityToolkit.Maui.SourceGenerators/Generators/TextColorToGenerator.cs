using System.Text;
using CommunityToolkit.Maui.SourceGenerators.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CommunityToolkit.Maui.SourceGenerators.Generators;

[Generator]
class TextColorToGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Get All Classes in User Library
		var candidateClassesProvider = context.SyntaxProvider.CreateSyntaxProvider(
			(syntaxNode, cancellationToken) => syntaxNode is ClassDeclarationSyntax classDeclarationSyntax,
			(context, cancellationToken) => (ClassDeclarationSyntax)context.Node);

		// Get Microsoft.Maui.Controls Assymbly Symbol
		var mauiControlsAssemblySymbolProvider = context.CompilationProvider.Select(
			(compilation, token) => compilation.SourceModule.ReferencedAssemblySymbols.Single(q => q.Name == "Microsoft.Maui.Controls"));

		var inputs = candidateClassesProvider.Collect()
						.Combine(mauiControlsAssemblySymbolProvider)
						.Select((combined, cancellationToken) => (CandidateClassesProvider: combined.Left, MauiControlsAssemblySymbolProvider: combined.Right));

		context.RegisterSourceOutput(inputs, (context, collectedValues) =>
		{
			var textStyleClassList = new List<(string ClassName, string ClassAcessModifier, string Namespace)>();

			// Collect Microsoft.Maui.Controls that Implement ITextStyle
			foreach (var namedTypeSymbol in collectedValues.MauiControlsAssemblySymbolProvider.GlobalNamespace.GetNamedTypeSymbols())
			{
				if (namedTypeSymbol.ImplementsInterfaceOrBaseClass("ITextStyle"))
				{
					textStyleClassList.Add((namedTypeSymbol.Name, "public", namedTypeSymbol.ContainingNamespace.ToString()));
				}
			}

			// Collect All Classes in User Library that Implement ITextStyle
			foreach (var classDeclarationSyntax in collectedValues.CandidateClassesProvider)
			{
				if (classDeclarationSyntax.BaseList?.Types.Any(x => x.ToString() == "ITextStyle") is true)
				{
					textStyleClassList.Add((classDeclarationSyntax.Identifier.ToString(), GetClassAccessModifier(classDeclarationSyntax), GetNamespace(classDeclarationSyntax)));
				}
			}

			foreach (var textStyleClass in textStyleClassList)
			{
				var textColorToBuilder = new StringBuilder(@"
// AutoGenerated Code
// See: CommunityToolkit.Maui.SourceGenerators.TextColorToGenerator

using System;
using System.Threading.Tasks;
using CommunityToolkit.Maui.Core.Extensions;
using Microsoft.Maui;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Graphics;

namespace " + textStyleClass.Namespace + @";

" + textStyleClass.ClassAcessModifier + @" static partial class ColorAnimationExtensions_" + textStyleClass.ClassName + @"
{
	/// <summary>
	/// Animates the TextColor of an <see cref=""ITextStyle""/> to the given color
	/// </summary>
	/// <param name=""element""></param>
	/// <param name=""color"">The target color to animate the <see cref=""ITextStyle.TextColor""/> to</param>
	/// <param name=""rate"">The time, in milliseconds, between the frames of the animation</param>
	/// <param name=""length"">The duration, in milliseconds, of the animation</param>
	/// <param name=""easing"">The easing function to be used in the animation</param>
	/// <returns>Value indicating if the animation completed successfully or not</returns>
	public static Task<bool> TextColorTo(this " + textStyleClass.Namespace + "." + textStyleClass.ClassName + @" element, Color color, uint rate = 16u, uint length = 250u, Easing? easing = null)
	{
		ArgumentNullException.ThrowIfNull(element);
		ArgumentNullException.ThrowIfNull(color);

		if(element is not ITextStyle)
			throw new ArgumentException($""Element must implement {nameof(ITextStyle)}"", nameof(element));

		//Although TextColor is defined as not-nullable, it CAN be null
		//If null => set it to Transparent as Animation will crash on null BackgroundColor
		element.TextColor ??= Colors.Transparent;

		var animationCompletionSource = new TaskCompletionSource<bool>();

		try
		{
			new Animation
			{
				{ 0, 1, GetRedTransformAnimation(element, color.Red) },
				{ 0, 1, GetGreenTransformAnimation(element, color.Green) },
				{ 0, 1, GetBlueTransformAnimation(element, color.Blue) },
				{ 0, 1, GetAlphaTransformAnimation(element, color.Alpha) },
			}
			.Commit(element, nameof(TextColorTo), rate, length, easing, (d, b) => animationCompletionSource.SetResult(true));
		}
		catch (ArgumentException aex)
		{
			//When creating an Animation too early in the lifecycle of the Page, i.e. in the OnAppearing method,
			//the Page might not have an 'IAnimationManager' yet, resulting in an ArgumentException.
			System.Diagnostics.Debug.WriteLine($""{aex.GetType().Name} thrown in {typeof(ColorAnimationExtensions_" + textStyleClass.ClassName + @").FullName}: {aex.Message}"");
			animationCompletionSource.SetResult(false);
		}

		return animationCompletionSource.Task;


		static Animation GetRedTransformAnimation(" + textStyleClass.Namespace + "." + textStyleClass.ClassName + @"  element, float targetRed) =>
			new(v => element.TextColor = element.TextColor.WithRed(v), element.TextColor.Red, targetRed);

		static Animation GetGreenTransformAnimation(" + textStyleClass.Namespace + "." + textStyleClass.ClassName + @"  element, float targetGreen) =>
			new(v => element.TextColor = element.TextColor.WithGreen(v), element.TextColor.Green, targetGreen);

		static Animation GetBlueTransformAnimation(" + textStyleClass.Namespace + "." + textStyleClass.ClassName + @"  element, float targetBlue) =>
			new(v => element.TextColor = element.TextColor.WithBlue(v), element.TextColor.Blue, targetBlue);

		static Animation GetAlphaTransformAnimation(" + textStyleClass.Namespace + "." + textStyleClass.ClassName + @"  element, float targetAlpha) =>
			new(v => element.TextColor = element.TextColor.WithAlpha(v), element.TextColor.Alpha, targetAlpha);
	}
}");
				context.AddSource($"{textStyleClass.ClassName}TextColorTo.g.shared.cs", SourceText.From(textColorToBuilder.ToString(), Encoding.UTF8));
			}
		});
	}

	static string GetNamespace(ClassDeclarationSyntax source)
	{
		SyntaxNode parent = source.Parent ?? throw new ArgumentException("ClassDeclarationSyntax must have a parent node");

		while (parent.IsKind(SyntaxKind.ClassDeclaration))
		{
			parent = parent.Parent ?? throw new ArgumentException("ClassDeclarationSyntax must have a parent node");
		}

		var namespaceDeclarationSyntax = (BaseNamespaceDeclarationSyntax)parent;

		return namespaceDeclarationSyntax.Name.ToString();
	}

	static string GetClassAccessModifier(ClassDeclarationSyntax source)
	{
		var modifiers = source.Modifiers;

		if (!modifiers.Any() || modifiers.Any(x => x.IsKind(SyntaxKind.InternalKeyword)))
			return "internal";

		if (modifiers.Any(x => x.IsKind(SyntaxKind.PublicKeyword)))
			return "public";

		// "Classes, records, and structs declared directly within a namespace (in other words, that aren't nested within other classes or structs) can be either public or internal"
		//  Source: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers#class-record-and-struct-accessibility
		throw new NotSupportedException("TextColorTo only supports public and internal classes ineriting from ITextStyle");
	}
}