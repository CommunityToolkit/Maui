using System.Collections.Immutable;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using CommunityToolkit.Maui.SourceGenerators.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CommunityToolkit.Maui.SourceGenerators.Internal;

[Generator]
public class AttachedBindablePropertyAttributeSourceGenerator : IIncrementalGenerator
{
	static readonly AttachedBindablePropertySemanticValues emptyAttachedBindablePropertySemanticValues = new(default, []);

	const string bindablePropertyFullName = "global::Microsoft.Maui.Controls.BindableProperty";
	const string bindableObjectFullName = "global::Microsoft.Maui.Controls.BindableObject";
	const string attachedBindablePropertyAttributeSource =
		/* language=C#-test */
		//lang=csharp
		$$"""
		  // <auto-generated>
		  // See: CommunityToolkit.Maui.SourceGenerators.Internal.AttachedBindablePropertySourceGenerator

		  #pragma warning disable
		  #nullable enable
		  namespace CommunityToolkit.Maui;

		  [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
		  [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Constructor, AllowMultiple = true, Inherited = false)]
		  [global::System.Diagnostics.CodeAnalysis.Experimental("{{BindablePropertyDiagnostic.BindablePropertyAttributeExperimentalDiagnosticId}}")]
		  public sealed partial class AttachedBindablePropertyAttribute<T>(string propertyName, bool isNullable = false) : global::System.Attribute where T : notnull
		  {
		  	public string PropertyName { get; } = propertyName;
		  	public bool DeclaringTypeIsNullable { get; } = isNullable;
		  	public T DefaultValue { get; init; }
		  	public global::Microsoft.Maui.Controls.BindingMode DefaultBindingMode { get; init; }
		  	public string ValidateValueMethodName { get; init; } = string.Empty;
		  	public string PropertyChangedMethodName { get; init; } = string.Empty;
		  	public string PropertyChangingMethodName { get; init; } = string.Empty;
		  	public string CoerceValueMethodName { get; init; } = string.Empty;
		  	public string DefaultValueCreatorMethodName { get; init; } = string.Empty;
		  	public string? BindablePropertyXmlDocumentation { get; init; }
		  	public string? GetterMethodXmlDocumentation { get; init; }
		  	public string? SetterMethodXmlDocumentation { get; init; }
		  	public global::CommunityToolkit.Maui.AccessModifier BindablePropertyAccessibility { get; init; } = global::CommunityToolkit.Maui.AccessModifier.Public;
		  	public global::CommunityToolkit.Maui.AccessModifier GetterAccessibility { get; init; } = global::CommunityToolkit.Maui.AccessModifier.Public;
		  	public global::CommunityToolkit.Maui.AccessModifier SetterAccessibility { get; init; } = global::CommunityToolkit.Maui.AccessModifier.Public;
		  }
		  """;

	const string accessibilityEnumSource =
		/* language=C#-test */
		//lang=csharp
		$$"""
		  // <auto-generated>
		  // See: CommunityToolkit.Maui.SourceGenerators.Internal.AttachedBindablePropertySourceGenerator

		  #pragma warning disable
		  #nullable enable
		  namespace CommunityToolkit.Maui;

		  public enum AccessModifier
		  {
		  	Public = 0,
		  	Internal = 1,
		  	ProtectedInternal = 2,
		  	Protected = 3,
		  	PrivateProtected = 4,
		  	Private = 5,
		  	None = 6
		  }
		  """;

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
#if DEBUG
		if (!Debugger.IsAttached)
		{
			// To debug this SG, uncomment the line below and rebuild the SourceGenerator project.
			//Debugger.Launch();
		}
#endif

		context.RegisterPostInitializationOutput(static ctx => ctx.AddSource("AttachedBindablePropertyAttribute.g.cs", SourceText.From(attachedBindablePropertyAttributeSource, Encoding.UTF8)));
		context.RegisterPostInitializationOutput(static ctx => ctx.AddSource("AccessModifier.g.cs", SourceText.From(accessibilityEnumSource, Encoding.UTF8)));

		var classProvider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.AttachedBindablePropertyAttribute`1",
				IsNonEmptyClassDeclarationSyntax, SemanticTransform)
			.Where(static x => x.ClassInformation != default || !x.BindableProperties.IsEmpty)
			.Collect();

		var constructorProvider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.AttachedBindablePropertyAttribute`1",
				IsNonEmptyConstructorDeclarationSyntax, SemanticTransformConstructor)
			.Where(static x => x.ClassInformation != default || !x.BindableProperties.IsEmpty)
			.Collect();

		context.RegisterSourceOutput(classProvider, ExecuteAllValues);
		context.RegisterSourceOutput(constructorProvider, ExecuteAllValues);
	}

	static void ExecuteAllValues(SourceProductionContext context, ImmutableArray<AttachedBindablePropertySemanticValues> semanticValues)
	{
		// Pre-allocate dictionary with expected capacity
		var groupedValues = new Dictionary<(string, string, string, string), List<AttachedBindablePropertySemanticValues>>(semanticValues.Length);

		// Single-pass grouping without LINQ
		foreach (var sv in semanticValues)
		{
			var key = (sv.ClassInformation.ClassName, sv.ClassInformation.ContainingNamespace, sv.ClassInformation.ContainingTypes, sv.ClassInformation.GenericTypeParameters);

			if (!groupedValues.TryGetValue(key, out var list))
			{
				list = [];
				groupedValues[key] = list;
			}
			list.Add(sv);
		}

		// Use ArrayPool for temporary storage
		var attachedBindablePropertiesBuffer = System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Rent(32);

		try
		{
			foreach (var keyValuePair in groupedValues)
			{
				var (className, containingNamespace, containingTypes, genericTypeParameters) = keyValuePair.Key;
				var values = keyValuePair.Value;

				if (values.Count is 0 || string.IsNullOrEmpty(className) || string.IsNullOrEmpty(containingNamespace))
				{
					continue;
				}

				// Flatten attached bindable properties without SelectMany allocation
				var attachedBindablePropertiesCount = 0;
				foreach (var value in values)
				{
					foreach (var abp in value.BindableProperties.AsImmutableArray())
					{
						if (attachedBindablePropertiesCount >= attachedBindablePropertiesBuffer.Length)
						{
							var newBuffer = System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Rent(attachedBindablePropertiesBuffer.Length * 2);
							Array.Copy(attachedBindablePropertiesBuffer, newBuffer, attachedBindablePropertiesBuffer.Length);
							System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Return(attachedBindablePropertiesBuffer);
							attachedBindablePropertiesBuffer = newBuffer;
						}
						attachedBindablePropertiesBuffer[attachedBindablePropertiesCount++] = abp;
					}
				}

				var attachedBindableProperties = ImmutableArray.Create(attachedBindablePropertiesBuffer, 0, attachedBindablePropertiesCount);

				var classAccessibility = values[0].ClassInformation.DeclaredAccessibility;

				var combinedClassInfo = new ClassInformation(className, classAccessibility, containingNamespace, containingTypes, genericTypeParameters);
				var combinedValues = new AttachedBindablePropertySemanticValues(combinedClassInfo, attachedBindableProperties.AsEquatableArray());

				var fileNameSuffix = string.IsNullOrEmpty(containingTypes) ? className : string.Concat(containingTypes, ".", className);
				var source = GenerateSource(combinedValues);
				SourceStringService.FormatText(ref source);
				context.AddSource($"{fileNameSuffix}.g.cs", SourceText.From(source, Encoding.UTF8));
			}
		}
		finally
		{
			System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Return(attachedBindablePropertiesBuffer);
		}
	}

	static string GenerateSource(AttachedBindablePropertySemanticValues value)
	{
		// Pre-calculate StringBuilder capacity to avoid resizing
		var estimatedCapacity = 500 + (value.BindableProperties.AsImmutableArray().Length * 500);
		var sb = new StringBuilder(estimatedCapacity);

		sb.Append("// <auto-generated>\n// See: CommunityToolkit.Maui.SourceGenerators.Internal.AttachedBindablePropertyAttributeSourceGenerator\n\n#pragma warning disable\n#nullable enable\n\n");

		if (!IsGlobalNamespace(value.ClassInformation))
		{
			sb.Append("namespace ").Append(value.ClassInformation.ContainingNamespace).Append(";\n\n");
		}

		// Generate nested class hierarchy
		if (!string.IsNullOrEmpty(value.ClassInformation.ContainingTypes))
		{
			var containingTypeNames = value.ClassInformation.ContainingTypes.Split('.');
			foreach (var typeName in containingTypeNames)
			{
				sb.Append(value.ClassInformation.DeclaredAccessibility).Append(" partial class ").Append(typeName).Append("\n{\n\n");
			}
		}

		// Get the class name with generic parameters
		var classNameWithGenerics = value.ClassInformation.ClassName;
		if (!string.IsNullOrEmpty(value.ClassInformation.GenericTypeParameters))
		{
			classNameWithGenerics = string.Concat(value.ClassInformation.ClassName, "<", value.ClassInformation.GenericTypeParameters, ">");
		}

		sb.Append(value.ClassInformation.DeclaredAccessibility).Append(" partial class ").Append(classNameWithGenerics).Append("\n{\n\n");

		// Build fully-qualified declaring type name
		var fullDeclaringType = BuildFullyQualifiedTypeName(value.ClassInformation, classNameWithGenerics);

		foreach (var info in value.BindableProperties.AsImmutableArray())
		{
			GenerateAttachedBindableProperty(sb, in info, fullDeclaringType);
		}

		sb.Append('}');

		// Close nested class hierarchy
		if (!string.IsNullOrEmpty(value.ClassInformation.ContainingTypes))
		{
			var containingTypeNames = value.ClassInformation.ContainingTypes.Split('.');
			for (int i = 0; i < containingTypeNames.Length; i++)
			{
				sb.Append("\n}");
			}
		}

		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string BuildFullyQualifiedTypeName(ClassInformation classInfo, string classNameWithGenerics)
	{
		if (IsGlobalNamespace(classInfo))
		{
			return string.IsNullOrEmpty(classInfo.ContainingTypes)
				? classNameWithGenerics
				: $"{classInfo.ContainingTypes}.{classNameWithGenerics}";
		}

		return string.IsNullOrEmpty(classInfo.ContainingTypes)
			? $"{classInfo.ContainingNamespace}.{classNameWithGenerics}"
			: $"{classInfo.ContainingNamespace}.{classInfo.ContainingTypes}.{classNameWithGenerics}";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static void GenerateAttachedBindableProperty(StringBuilder sb, in AttachedBindablePropertyModel info, string fullDeclaringType)
	{
		// Sanitize the Return Type because Nullable Reference Types cannot be used in the `typeof()` operator
		var nonNullableReturnType = ConvertToNonNullableTypeSymbol(info.ReturnType);
		var sanitizedPropertyName = IsDotnetKeyword(info.PropertyName) ? string.Concat("@", info.PropertyName) : info.PropertyName;
		var formattedReturnType = GetFormattedReturnType(info.ReturnType, info.ShouldPostpendNullable);
		var nonNullableFormattedType = GetFormattedTypeForTypeOf(nonNullableReturnType);

		// Generate BindableProperty
		if (info.BindablePropertyXMLDocumentation is not null)
		{
			sb.Append(info.BindablePropertyXMLDocumentation)
				.Append("\r\n");
		}
		else
		{
			sb.Append("/// <summary>\r\n/// Attached BindableProperty for the ")
				.Append(sanitizedPropertyName)
				.Append(" property.\r\n/// </summary>\r\n");
		}

		sb.Append(info.BindablePropertyAccessibility)
			.Append("static readonly ")
			.Append(bindablePropertyFullName)
			.Append(" ")
			.Append(info.BindablePropertyName)
			.Append(" = ")
			.Append(bindablePropertyFullName)
			.Append(".CreateAttached(\"")
			.Append(sanitizedPropertyName)
			.Append("\", typeof(")
			.Append(nonNullableFormattedType)
			.Append("), typeof(")
			.Append(fullDeclaringType)
			.Append("), ")
			.Append(info.DefaultValue)
			.Append(", ")
			.Append(info.DefaultBindingMode)
			.Append(", ")
			.Append(info.ValidateValueMethodName)
			.Append(", ")
			.Append(info.PropertyChangedMethodName)
			.Append(", ")
			.Append(info.PropertyChangingMethodName)
			.Append(", ")
			.Append(info.CoerceValueMethodName)
			.Append(", ")
			.Append(info.DefaultValueCreatorMethodName)
			.Append(");\n\n");

		// Generate Get method
		if (info.GetterAccessibility is not null)
		{

			if (info.GetterMethodXMLDocumentation is not null)
			{
				sb.Append(info.GetterMethodXMLDocumentation)
					.Append("\r\n");
			}
			else
			{
				sb.Append("/// <summary>\r\n/// Gets ")
					.Append(sanitizedPropertyName)
					.Append(" for the <paramref name=\"bindable\"/> child element.\r\n/// </summary>\r\n");
			}

			sb.Append(info.GetterAccessibility)
				.Append("static ")
				.Append(formattedReturnType)
				.Append(" Get")
				.Append(info.PropertyName)
				.Append("(")
				.Append(bindableObjectFullName)
				.Append(" bindable) => (")
				.Append(formattedReturnType)
				.Append(")bindable.GetValue(")
				.Append(info.BindablePropertyName)
				.Append(");\n\n");
		}

		// Generate Set method
		if (info.SetterAccessibility is not null)
		{
			if (info.SetterMethodXMLDocumentation is not null)
			{
				sb.Append(info.SetterMethodXMLDocumentation)
					.Append("\r\n");
			}
			else
			{
				sb.Append("/// <summary>\r\n/// Sets ")
					.Append(sanitizedPropertyName)
					.Append(" for the <paramref name=\"bindable\"/> child element.\r\n/// </summary>\r\n");
			}

			sb.Append(info.SetterAccessibility)
				.Append("static void Set")
				.Append(info.PropertyName)
				.Append("(")
				.Append(bindableObjectFullName)
				.Append(" bindable, ")
				.Append(formattedReturnType)
				.Append(" value) => bindable.SetValue(")
				.Append(info.BindablePropertyName)
				.Append(", value);\n\n");
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static AttachedBindablePropertySemanticValues SemanticTransform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var classDeclarationSyntax = (ClassDeclarationSyntax)context.TargetNode;
		var semanticModel = context.SemanticModel;
		var classSymbol = (INamedTypeSymbol?)ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax, cancellationToken);

		if (classSymbol is null)
		{
			return emptyAttachedBindablePropertySemanticValues;
		}

		return ExtractAttachedBindableProperties(classSymbol, context.Attributes, cancellationToken);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static AttachedBindablePropertySemanticValues SemanticTransformConstructor(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var constructorDeclarationSyntax = (ConstructorDeclarationSyntax)context.TargetNode;
		var semanticModel = context.SemanticModel;
		var constructorSymbol = (IMethodSymbol?)ModelExtensions.GetDeclaredSymbol(semanticModel, constructorDeclarationSyntax, cancellationToken);

		if (constructorSymbol is null || constructorSymbol.ContainingType is null)
		{
			return emptyAttachedBindablePropertySemanticValues;
		}

		return ExtractAttachedBindableProperties(constructorSymbol.ContainingType, context.Attributes, cancellationToken);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static AttachedBindablePropertySemanticValues ExtractAttachedBindableProperties(INamedTypeSymbol classSymbol, ImmutableArray<AttributeData> attributes, CancellationToken cancellationToken)
	{
		var @namespace = classSymbol.ContainingNamespace.ToDisplayString();
		var className = classSymbol.Name;
		var classAccessibility = classSymbol.DeclaredAccessibility.ToString().ToLower();

		// Build containing types hierarchy
		var containingTypes = GetContainingTypes(classSymbol);

		// Extract generic type parameters
		var genericTypeParameters = GetGenericTypeParameters(classSymbol);

		var classInfo = new ClassInformation(className, classAccessibility, @namespace, containingTypes, genericTypeParameters);

		// Use array for attached bindable properties
		var attachedBindablePropertyModels = new AttachedBindablePropertyModel[attributes.Length];

		for (int i = 0; i < attributes.Length; i++)
		{
			var attributeData = attributes[i];
			attachedBindablePropertyModels[i] = CreateAttachedBindablePropertyModel(attributeData, classSymbol);
		}

		return new(classInfo, ImmutableArray.Create(attachedBindablePropertyModels).AsEquatableArray());
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static AttachedBindablePropertyModel CreateAttachedBindablePropertyModel(AttributeData attributeData, INamedTypeSymbol declaringType)
	{
		if (attributeData.AttributeClass is null || attributeData.ConstructorArguments.Length is 0)
		{
			throw new ArgumentException("Invalid attribute data");
		}

		// Get property name from constructor argument
		var propertyNameArg = attributeData.ConstructorArguments[0];
		var propertyName = propertyNameArg.Value as string ?? throw new InvalidOperationException("Property name must be a string");

		// Validate property name starts with uppercase
		if (string.IsNullOrEmpty(propertyName) || char.IsLower(propertyName[0]))
		{
			throw new NotSupportedException($"Property name '{propertyName}' must start with an uppercase letter");
		}

		// Get the generic type argument (the T in AttachedBindableProperty<T>)
		var typeArg = (attributeData.AttributeClass?.TypeArguments.FirstOrDefault()) ?? throw new InvalidOperationException("Could not determine property type from attribute");
		var isDeclaringTypeNullable = (bool)(attributeData.ConstructorArguments[1].Value ?? throw new InvalidOperationException("DeclaringTypeIsNullable cannot be null"));

		var defaultValue = GetDefaultValueString(attributeData, typeArg, isDeclaringTypeNullable && typeArg.OriginalDefinition.SpecialType is not SpecialType.System_Nullable_T);
		var defaultBindingMode = attributeData.GetNamedTypeArgumentsAttributeValueForDefaultBindingMode("DefaultBindingMode", "(Microsoft.Maui.Controls.BindingMode)0");
		var validateValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("ValidateValueMethodName");
		var propertyChangedMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("PropertyChangedMethodName");
		var propertyChangingMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("PropertyChangingMethodName");
		var coerceValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("CoerceValueMethodName");
		var defaultValueCreatorMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("DefaultValueCreatorMethodName");

		var getterAccessibility = GetAccessibilityString(attributeData, "GetterAccessibility");
		var setterAccessibility = GetAccessibilityString(attributeData, "SetterAccessibility");
		var bindablePropertyAccessibility = GetAccessibilityString(attributeData, "BindablePropertyAccessibility")
			?? throw new InvalidOperationException("Bindable Property Accessibilty Cannot be null");

		var getterMethodXMLDocumentation = GetXMLDocumenation(attributeData, "GetterMethodXmlDocumentation");
		var setterMethodXMLDocumentation = GetXMLDocumenation(attributeData, "SetterMethodXmlDocumentation");
		var bindablePropertyXMLDocumentation = GetXMLDocumenation(attributeData, "BindablePropertyXmlDocumentation");

		return new AttachedBindablePropertyModel(
			propertyName,
			typeArg,
			declaringType,
			defaultValue,
			defaultBindingMode,
			validateValueMethodName,
			propertyChangedMethodName,
			propertyChangingMethodName,
			coerceValueMethodName,
			defaultValueCreatorMethodName,
			getterAccessibility,
			setterAccessibility,
			bindablePropertyAccessibility,
			isDeclaringTypeNullable,
			bindablePropertyXMLDocumentation,
			getterMethodXMLDocumentation,
			setterMethodXMLDocumentation
		);
	}
	// DefaultValue can only be a primitive type, enum, typeof expression or array
	// In C#, attribute arguments are limited to compile-time constants, typeof expressions, and single-dimensional arrays
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetDefaultValueString(AttributeData attributeData, ITypeSymbol typeArg, bool shouldPostpendNullableSymbol)
	{
		var defaultValueArg = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key is "DefaultValue");

		if (defaultValueArg.Value.IsNull)
		{
			return "null";
		}

		var value = defaultValueArg.Value;

		// Handle Arrays
		if (typeArg.TypeKind is TypeKind.Array)
		{
			return GetFormattedArrayValue(value, GetFormattedReturnType(typeArg, shouldPostpendNullableSymbol));
		}

		// Handle null values
		if (value.Value is null)
		{
			return "null";
		}

		var typeSymbol = GetFormattedReturnType(typeArg, shouldPostpendNullableSymbol);

		return value.Value switch
		{
			// Handle char
			char charVal => $"({typeSymbol})'{charVal}'",

			// Handle string
			string stringVal => $"({typeSymbol})\"{GetEscapedString(stringVal)}\"",

			// Handle enums and all remaining compile-time constants
			_ => $"({typeSymbol}){GetFormattedConstantValue(value)}"
		};
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string? GetXMLDocumenation(AttributeData attributeData, string parameterName)
	{
		var xmlDocumentation = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key == parameterName)
			.Value;

		if (xmlDocumentation.IsNull || xmlDocumentation.Value is null)
		{
			return null;
		}

		return xmlDocumentation.Value.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string? GetAccessibilityString(AttributeData attributeData, string parameterName)
	{
		var accessibility = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key == parameterName)
			.Value;

		if (accessibility.IsNull || accessibility.Value is null)
		{
			return "public ";
		}

		var enumValue = (int)accessibility.Value;

		return enumValue switch
		{
			0 => "public ",
			1 => "internal ",
			2 => "protected internal ",
			3 => "protected ",
			4 => "private protected ",
			5 => "private ",
			6 => null,
			_ => throw new NotSupportedException($"{accessibility.Value} is not yet supported")
		};
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsNonEmptyClassDeclarationSyntax(SyntaxNode node, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsNonEmptyConstructorDeclarationSyntax(SyntaxNode node, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return node is ConstructorDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsDotnetKeyword(in string name) => SyntaxFacts.GetKeywordKind(name) is not SyntaxKind.None;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsGlobalNamespace(in ClassInformation classInformation) => classInformation.ContainingNamespace is "<global namespace>" or "";

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetContainingTypes(INamedTypeSymbol typeSymbol)
	{
		var current = typeSymbol.ContainingType;
		if (current is null)
		{
			return string.Empty;
		}

		var sb = new StringBuilder(100);
		var stack = new Stack<string>(4);

		while (current is not null)
		{
			stack.Push(current.Name);
			current = current.ContainingType;
		}

		var first = true;
		while (stack.Count > 0)
		{
			if (!first)
			{
				sb.Append('.');
			}
			sb.Append(stack.Pop());
			first = false;
		}

		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetGenericTypeParameters(INamedTypeSymbol typeSymbol)
	{
		if (!typeSymbol.IsGenericType || typeSymbol.TypeParameters.IsEmpty)
		{
			return string.Empty;
		}

		var typeParams = typeSymbol.TypeParameters;
		if (typeParams.Length is 1)
		{
			return typeParams[0].Name;
		}

		var sb = new StringBuilder(typeParams.Length * 10);
		for (int i = 0; i < typeParams.Length; i++)
		{
			if (i > 0)
			{
				sb.Append(", ");
			}
			sb.Append(typeParams[i].Name);
		}

		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static ITypeSymbol ConvertToNonNullableTypeSymbol(in ITypeSymbol typeSymbol)
	{
		// Check for Nullable<T>
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nullableType)
		{
			return nullableType.TypeArguments[0];
		}

		// Check for Nullable Reference Type
		if (typeSymbol.NullableAnnotation is NullableAnnotation.Annotated)
		{
			return typeSymbol.WithNullableAnnotation(NullableAnnotation.None);
		}

		return typeSymbol;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetFormattedReturnType(ITypeSymbol typeSymbol, bool shouldPostpendNullableSymbol)
	{
		var formattedType = GetFormattedTypeForTypeOf(typeSymbol);

		return shouldPostpendNullableSymbol ? $"{formattedType}?" : formattedType;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetFormattedTypeForTypeOf(ITypeSymbol typeSymbol)
	{
		if (typeSymbol is IArrayTypeSymbol arrayTypeSymbol)
		{
			string elementType = GetFormattedTypeForTypeOf(arrayTypeSymbol.ElementType);
			var rank = arrayTypeSymbol.Rank > 1 ? new string(',', arrayTypeSymbol.Rank - 1) : string.Empty;
			return string.Concat(elementType, "[", rank, "]");
		}

		return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetEscapedString(string value)
	{
		return value
			.Replace("\\", "\\\\")
			.Replace("\"", "\\\"")
			.Replace("\n", "\\n")
			.Replace("\r", "\\r")
			.Replace("\t", "\\t");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetFormattedArrayValue(TypedConstant arrayConstant, string typeSymbol)
	{
		if (arrayConstant.Values.Length is 0)
		{
			return $"({typeSymbol})[]";
		}

		// Single-dimensional array
		var sb = new StringBuilder();
		sb.Append("(").Append(typeSymbol).Append(")new[] { ");

		for (int i = 0; i < arrayConstant.Values.Length; i++)
		{
			if (i > 0)
			{
				sb.Append(", ");
			}

			var element = arrayConstant.Values[i];
			sb.Append(GetFormattedConstantValue(element));
		}

		sb.Append(" }");
		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetFormattedConstantValue(TypedConstant constant)
	{
		if (constant.IsNull)
		{
			return "null";
		}

		return constant.Value switch
		{
			true => "true",
			false => "false",
			int intVal => intVal.ToString(),
			byte byteVal => byteVal.ToString(),
			sbyte sbyteVal => sbyteVal.ToString(),
			short shortVal => shortVal.ToString(),
			ushort ushortVal => ushortVal.ToString(),
			long longVal => $"{longVal}L",
			uint uintVal => $"{uintVal}U",
			ulong ulongVal => $"{ulongVal}UL",
			double doubleVal => doubleVal switch
			{
				double.NaN => "double.NaN",
				double.PositiveInfinity => "double.PositiveInfinity",
				double.NegativeInfinity => "double.NegativeInfinity",
				double.Epsilon => "double.Epsilon",
				double.MaxValue => "double.MaxValue",
				double.MinValue => "double.MinValue",
				_ => doubleVal.ToString("G17")
			},
			float floatVal => floatVal switch
			{
				float.NaN => "float.NaN",
				float.PositiveInfinity => "float.PositiveInfinity",
				float.NegativeInfinity => "float.NegativeInfinity",
				float.Epsilon => "float.Epsilon",
				float.MaxValue => "float.MaxValue",
				float.MinValue => "float.MinValue",
				_ => $"{floatVal:G9}f"
			},
			char charVal => $"'{charVal}'",
			string stringVal => $"\"{GetEscapedString(stringVal)}\"",
			_ => "null"
		};
	}
}