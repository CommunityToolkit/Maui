using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;
using CommunityToolkit.Maui.SourceGenerators.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CommunityToolkit.Maui.SourceGenerators.Internal;

[Generator]
public class AttachedBindablePropertyAttributeSourceGenerator : IIncrementalGenerator
{
	static readonly AttachedBindablePropertySemanticValues emptyAttachedBindablePropertySemanticValues = new(default, []);

	const string bindablePropertyFullName = "global::Microsoft.Maui.Controls.BindableProperty";
	const string bindableObjectFullName = "global::Microsoft.Maui.Controls.BindableObject";

	const string attachedBindablePropertyAttributeSource =
		/* language=C#-test */
		//lang=csharp
		$$"""
		  // <auto-generated>
		  // See: CommunityToolkit.Maui.SourceGenerators.Internal.AttachedBindablePropertySourceGenerator

		  #pragma warning disable
		  #nullable enable
		  namespace CommunityToolkit.Maui;

		  [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
		  [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Constructor, AllowMultiple = true, Inherited = false)]
		  [global::System.Diagnostics.CodeAnalysis.Experimental("{{BindablePropertyDiagnostic.BindablePropertyAttributeExperimentalDiagnosticId}}")]
		  ///<summary> Source generater that creates an Attached <see cref="Microsoft.Maui.Controls.BindableProperty"/> and two <see langword="static"/> methods: <c>Get{PropertyName}(BindableProperty bindable)</c> and <c>Set{PropertyName}(BindableProperty bindable, T value)</c></summary>
		  ///<typeparam name="T">Type of the Attached Bindable Property. Set <see cref="AttachedBindablePropertyAttribute.IsNullable"/> to <see langword="true"/> to generate a nullable type for <typeparamref name="T"/></typeparam>
		  ///<param name="propertyName">Name of the Attached Property</param>
		  ///<remarks> 
		  ///* Generates a <see langword="readonly"/> <see langword="static"/> <see cref="Microsoft.Maui.Controls.BindableProperty"/> field using <see cref="Microsoft.Maui.Controls.BindableProperty.CreateAttached(string, Type, Type, object, BindingMode, BindableProperty.ValidateValueDelegate, BindableProperty.BindingPropertyChangedDelegate, BindableProperty.BindingPropertyChangingDelegate, BindableProperty.CoerceValueDelegate, BindableProperty.BindablePropertyBindingChanging, bool, BindableProperty.CreateDefaultValueDelegate)"/><br/>
		  ///* Generates <see langword="static"/> <c>Get{PropertyName}(BindableProperty bindable)</c><br/>
		  ///* Generates <see langword="static"/> <c>Set{PropertyName}(BindableProperty bindable, T value)</c><br/>
		  ///* The property type <typeparamref name="T"/> will be treated as non-nullable unless <see cref="AttachedBindablePropertyAttribute.IsNullable"/> is set to <see langword="true"/>
		  ///</remarks>
		  public sealed partial class AttachedBindablePropertyAttribute<T>(string propertyName) : global::System.Attribute where T : notnull
		  {
		  	///<summary>Name of the Attached Property</summary>
		  	public string PropertyName { get; } = propertyName;
		  	///<summary>Should generate a nullable type for T</summary>
		  	public bool IsNullable { get; init; }
		  	///<summary>The default value for the property</summary>
		  	public T? DefaultValue { get; init; }
		  	///<summary>The BindingMode to use on SetBinding() if no BindingMode is given. Default is <see cref="Microsoft.Maui.Controls.BindableProperty.Default"/></summary>
		  	public global::Microsoft.Maui.Controls.BindingMode DefaultBindingMode { get; init; } = global::Microsoft.Maui.Controls.BindingMode.Default;
		  	///<summary>Method name for <see cref="Microsoft.Maui.Controls.ValidateValueDelegate"/> to be run when a value is set. Default value is null</summary>
		  	///<remarks>The referenced method must be <see cref="Microsoft.Maui.Controls.ValidateValueDelegate"/></remarks>
		  	public string? ValidateValueMethodName { get; init; }
		  	///<summary>Method name for <see cref="Microsoft.Maui.Controls.BindingPropertyChangedDelegate"/> to be run when a value has changed. Default value is null</summary>
		  	///<remarks>The referenced method must be <see cref="Microsoft.Maui.Controls.BindingPropertyChangedDelegate"/></remarks>
		  	public string? PropertyChangedMethodName { get; init; }
		  	///<summary>Method name for <see cref="Microsoft.Maui.Controls.BindingPropertyChangingDelegate"/> to be run when a value is set. Default value is null</summary>
		  	///<remarks>The referenced method must be <see cref="Microsoft.Maui.Controls.BindingPropertyChangingDelegate"/></remarks>
		  	public string? PropertyChangingMethodName { get; init; }
		  	///<summary>Method name for <see cref="Microsoft.Maui.Controls.CoerceValueDelegate"/> used to coerce the range of a value. Default value is null</summary>
		  	///<remarks>The referenced method must be <see cref="Microsoft.Maui.Controls.CoerceValueDelegate"/></remarks>
		  	public string? CoerceValueMethodName { get; init; }
		  	///<summary>Method name for <see cref="Microsoft.Maui.Controls.CreateDefaultValueDelegate"/> used to initialize default value for reference types. Default value is null</summary>
		  	///<remarks>The referenced method must be <see cref="Microsoft.Maui.Controls.CreateDefaultValueDelegate"/></remarks>
		  	public string? DefaultValueCreatorMethodName { get; init; }
		  	///<summary>Custom XML Comments added to BindableProperty</summary>
		  	///<remarks>Must be the entire XML string, including <c>///</c>
		  	///</remarks>
		  	public string? BindablePropertyXmlDocumentation { get; init; }
		  	///<summary>Custom XML Comments added to <c>Get{PropertyName}(BindableProperty bindable)</c></summary>
		  	///<remarks>Must be the entire XML string, including <c>///</c></remarks>
		  	public string? GetterMethodXmlDocumentation { get; init; }
		  	///<summary>Custom XML Comments added to <c>Set{PropertyName}(BindableProperty bindable, T value)</c></summary>
		  	///<remarks>Must be the entire XML string, including <c>///</c></remarks>
		  	public string? SetterMethodXmlDocumentation { get; init; }
		  	///<summary>The access modifier applied to the generated field <see cref="Microsoft.Maui.Controls.BindableProperty"/></summary>
		  	public global::CommunityToolkit.Maui.AccessModifier BindablePropertyAccessibility { get; init; } = global::CommunityToolkit.Maui.AccessModifier.Public;
		  	///<summary>The access modifier applied to the generated method <c>Get{PropertyName}(BindableProperty bindable)</c></summary>
		  	public global::CommunityToolkit.Maui.AccessModifier GetterAccessibility { get; init; } = global::CommunityToolkit.Maui.AccessModifier.Public;
		  	///<summary>The access modifier applied to the generated method <c>Set{PropertyName}(BindableProperty bindable, T value)</c></summary>
		  	public global::CommunityToolkit.Maui.AccessModifier SetterAccessibility { get; init; } = global::CommunityToolkit.Maui.AccessModifier.Public;
		  }
		  """;

	const string accessibilityEnumSource =
		/* language=C#-test */
		//lang=csharp
		$$"""
		  // <auto-generated>
		  // See: CommunityToolkit.Maui.SourceGenerators.Internal.AttachedBindablePropertySourceGenerator

		  #pragma warning disable
		  #nullable enable
		  namespace CommunityToolkit.Maui;

		  ///<summary>Used by CommunityToolkit.Maui source generators to define access modifiers for generated code</summary>
		  public enum AccessModifier
		  {
		  	///<summary>Generates <see langword="public"/> access modifier</summary>
		  	Public = 0,
		  	///<summary>Generates <see langword="internal"/> access modifier</summary>
		  	Internal = 1,
		  	///<summary>Generates <see langword="protected"/> <see langword="internal"/> access modifier</summary>
		  	ProtectedInternal = 2,
		  	///<summary>Generates <see langword="protected"/> access modifier</summary>
		  	Protected = 3,
		  	///<summary>Generates <see langword="private"/> <see langword="protected"/> access modifier</summary>
		  	PrivateProtected = 4,
		  	///<summary>Generates <see langword="private"/> access modifier</summary>
		  	Private = 5,
		  	///<summary>Generates no code</summary>
		  	None = 6
		  }
		  """;

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
#if DEBUG
		if (!Debugger.IsAttached)
		{
			// To debug this SG, uncomment the line below and rebuild the SourceGenerator project.
			//Debugger.Launch();
		}
#endif

		context.RegisterPostInitializationOutput(static ctx => ctx.AddSource("AttachedBindablePropertyAttribute.g.cs", SourceText.From(attachedBindablePropertyAttributeSource, Encoding.UTF8)));
		context.RegisterPostInitializationOutput(static ctx => ctx.AddSource("AccessModifier.g.cs", SourceText.From(accessibilityEnumSource, Encoding.UTF8)));

		var classProvider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.AttachedBindablePropertyAttribute`1",
				IsNonEmptyClassDeclarationSyntax, SemanticTransform)
			.Where(static x => x.ClassInformation != default || !x.BindableProperties.IsEmpty)
			.Collect();

		var constructorProvider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.AttachedBindablePropertyAttribute`1",
				IsNonEmptyConstructorDeclarationSyntax, SemanticTransformConstructor)
			.Where(static x => x.ClassInformation != default || !x.BindableProperties.IsEmpty)
			.Collect();

		context.RegisterSourceOutput(classProvider, ExecuteAllValues);
		context.RegisterSourceOutput(constructorProvider, ExecuteAllValues);
	}

	static void ExecuteAllValues(SourceProductionContext context, ImmutableArray<AttachedBindablePropertySemanticValues> semanticValues)
	{
		// Use ArrayPool for temporary storage
		var attachedBindablePropertiesBuffer = System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Rent(32);

		try
		{
			foreach (var attachedBindablePropertySemanticValues in semanticValues)
			{
				var className = attachedBindablePropertySemanticValues.ClassInformation.ClassName;
				var containingNamespace = attachedBindablePropertySemanticValues.ClassInformation.ContainingNamespace;
				var containingTypes = attachedBindablePropertySemanticValues.ClassInformation.ContainingTypes;
				var genericTypeParameters = attachedBindablePropertySemanticValues.ClassInformation.GenericTypeParameters;

				if (string.IsNullOrEmpty(className) || string.IsNullOrEmpty(containingNamespace))
				{
					continue;
				}

				// Flatten attached bindable properties without SelectMany allocation
				var attachedBindablePropertiesCount = 0;

				foreach (var abp in attachedBindablePropertySemanticValues.BindableProperties.AsImmutableArray())
				{
					if (attachedBindablePropertiesCount >= attachedBindablePropertiesBuffer.Length)
					{
						var newBuffer = System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Rent(attachedBindablePropertiesBuffer.Length * 2);
						Array.Copy(attachedBindablePropertiesBuffer, newBuffer, attachedBindablePropertiesBuffer.Length);
						System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Return(attachedBindablePropertiesBuffer);
						attachedBindablePropertiesBuffer = newBuffer;
					}

					attachedBindablePropertiesBuffer[attachedBindablePropertiesCount++] = abp;
				}

				var attachedBindablePropertiesArray = EquatableArray<AttachedBindablePropertyModel>.FromImmutableArray(ImmutableArray.Create(attachedBindablePropertiesBuffer, 0, attachedBindablePropertiesCount));

				var classAccessibility = attachedBindablePropertySemanticValues.ClassInformation.DeclaredAccessibility;

				var combinedClassInfo = new ClassInformation(className, classAccessibility, containingNamespace, containingTypes, genericTypeParameters);
				var combinedValues = new AttachedBindablePropertySemanticValues(combinedClassInfo, attachedBindablePropertiesArray);

				var fileNameSuffix = string.IsNullOrEmpty(containingTypes) ? className : string.Concat(containingTypes, ".", className);
				var source = GenerateSource(combinedValues);
				SourceStringService.FormatText(ref source);
				context.AddSource($"{fileNameSuffix}.g.cs", SourceText.From(source, Encoding.UTF8));
			}
		}
		finally
		{
			System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Return(attachedBindablePropertiesBuffer);
		}
	}

	static string GenerateSource(AttachedBindablePropertySemanticValues value)
	{
		// Pre-calculate StringBuilder capacity to avoid resizing
		var estimatedCapacity = 500 + (value.BindableProperties.AsImmutableArray().Length * 500);
		var sb = new StringBuilder(estimatedCapacity);

		sb.Append("// <auto-generated>\n// See: CommunityToolkit.Maui.SourceGenerators.Internal.AttachedBindablePropertyAttributeSourceGenerator\n\n#pragma warning disable\n#nullable enable\n\n");

		if (!IsGlobalNamespace(value.ClassInformation))
		{
			sb.Append("namespace ").Append(value.ClassInformation.ContainingNamespace).Append(";\n\n");
		}

		// Generate nested class hierarchy
		if (!string.IsNullOrEmpty(value.ClassInformation.ContainingTypes))
		{
			var containingTypeNames = value.ClassInformation.ContainingTypes.Split('.');
			foreach (var typeName in containingTypeNames)
			{
				sb.Append(value.ClassInformation.DeclaredAccessibility).Append(" partial class ").Append(typeName).Append("\n{\n\n");
			}
		}

		// Get the class name with generic parameters
		var classNameWithGenerics = value.ClassInformation.ClassName;
		if (!string.IsNullOrEmpty(value.ClassInformation.GenericTypeParameters))
		{
			classNameWithGenerics = string.Concat(value.ClassInformation.ClassName, "<", value.ClassInformation.GenericTypeParameters, ">");
		}

		sb.Append(value.ClassInformation.DeclaredAccessibility).Append(" partial class ").Append(classNameWithGenerics).Append("\n{\n\n");

		// Build fully-qualified declaring type name
		var fullDeclaringType = BuildFullyQualifiedTypeName(value.ClassInformation, classNameWithGenerics);

		foreach (var info in value.BindableProperties.AsImmutableArray())
		{
			if (info.IsReadOnlyBindableProperty)
			{
				GenerateAttachedReadOnlyBindableProperty(sb, in info, fullDeclaringType);
			}
			else
			{
				GenerateAttachedBindableProperty(sb, in info, fullDeclaringType);
			}
		}

		sb.Append('}');

		// Close nested class hierarchy
		if (!string.IsNullOrEmpty(value.ClassInformation.ContainingTypes))
		{
			var containingTypeNames = value.ClassInformation.ContainingTypes.Split('.');
			for (int i = 0; i < containingTypeNames.Length; i++)
			{
				sb.Append("\n}");
			}
		}

		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string BuildFullyQualifiedTypeName(ClassInformation classInfo, string classNameWithGenerics)
	{
		if (IsGlobalNamespace(classInfo))
		{
			return string.IsNullOrEmpty(classInfo.ContainingTypes)
				? classNameWithGenerics
				: $"{classInfo.ContainingTypes}.{classNameWithGenerics}";
		}

		return string.IsNullOrEmpty(classInfo.ContainingTypes)
			? $"{classInfo.ContainingNamespace}.{classNameWithGenerics}"
			: $"{classInfo.ContainingNamespace}.{classInfo.ContainingTypes}.{classNameWithGenerics}";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static void GenerateAttachedReadOnlyBindableProperty(StringBuilder sb, in AttachedBindablePropertyModel info, in string fullDeclaringType)
	{
		// Sanitize the Return Type because Nullable Reference Types cannot be used in the `typeof()` operator
		var nonNullableReturnType = ConvertToNonNullableTypeSymbol(info.ReturnType);
		var sanitizedPropertyName = IsDotnetKeyword(info.PropertyName) ? string.Concat("@", info.PropertyName) : info.PropertyName;
		var formattedReturnType = GetFormattedReturnType(info.ReturnType, info.ShouldPostpendNullable);
		var nonNullableFormattedType = GetFormattedTypeForTypeOf(nonNullableReturnType);

		// Generate BindablePropertyKey for read-only properties
		sb.Append("static readonly global::Microsoft.Maui.Controls.BindablePropertyKey ")
			.Append(info.BindablePropertyKeyName)
			.Append(" = \n")
			.Append(bindablePropertyFullName)
			.Append(".CreateAttachedReadOnly(\"")
			.Append(sanitizedPropertyName)
			.Append("\", typeof(")
			.Append(nonNullableReturnType)
			.Append("), typeof(")
			.Append(fullDeclaringType)
			.Append("),")
			.Append(info.DefaultValue)
			.Append(", ")
			.Append(info.DefaultBindingMode)
			.Append(", ")
			.Append(info.ValidateValueMethodName)
			.Append(", ")
			.Append(info.PropertyChangedMethodName)
			.Append(", ")
			.Append(info.PropertyChangingMethodName)
			.Append(", ")
			.Append(info.CoerceValueMethodName)
			.Append(", ");

		sb.Append(info.DefaultValueCreatorMethodName)
			.Append(");\n");

		sb.Append(info.EffectiveBindablePropertyXmlDocumentation)
			.Append("\r\n");

		// Generate public BindableProperty from the key
		sb.Append(info.BindablePropertyAccessibility)
			.Append("static readonly ")
			.Append(bindablePropertyFullName)
			.Append(' ')
			.Append(info.BindablePropertyName)
			.Append(" = ")
			.Append(info.BindablePropertyKeyName)
			.Append(".BindableProperty;\n");

		// Generate Get method
		if (info.GetterAccessibility is not null)
		{
			GenerateGetter(sb, info.EffectiveGetterMethodXmlDocumentation, info.GetterAccessibility, formattedReturnType, info.PropertyName, info.BindablePropertyName);
		}

		// Generate Set method
		if (info.SetterAccessibility is not null)
		{
			GenerateSetter(sb, info.EffectiveSetterMethodXmlDocumentation, info.SetterAccessibility, formattedReturnType, info.PropertyName, info.BindablePropertyName, info.BindablePropertyKeyName, info.IsReadOnlyBindableProperty);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static void GenerateAttachedBindableProperty(StringBuilder sb, in AttachedBindablePropertyModel info, string fullDeclaringType)
	{
		// Sanitize the Return Type because Nullable Reference Types cannot be used in the `typeof()` operator
		var nonNullableReturnType = ConvertToNonNullableTypeSymbol(info.ReturnType);
		var sanitizedPropertyName = IsDotnetKeyword(info.PropertyName) ? string.Concat("@", info.PropertyName) : info.PropertyName;
		var formattedReturnType = GetFormattedReturnType(info.ReturnType, info.ShouldPostpendNullable);
		var nonNullableFormattedType = GetFormattedTypeForTypeOf(nonNullableReturnType);

		// Generate BindableProperty
		sb.Append(info.EffectiveBindablePropertyXmlDocumentation)
			.Append("\r\n");

		sb.Append(info.BindablePropertyAccessibility)
			.Append("static readonly ")
			.Append(bindablePropertyFullName)
			.Append(' ')
			.Append(info.BindablePropertyName)
			.Append(" = ")
			.Append(bindablePropertyFullName)
			.Append(".CreateAttached(\"")
			.Append(sanitizedPropertyName)
			.Append("\", typeof(")
			.Append(nonNullableFormattedType)
			.Append("), typeof(")
			.Append(fullDeclaringType)
			.Append("), ")
			.Append(info.DefaultValue)
			.Append(", ")
			.Append(info.DefaultBindingMode)
			.Append(", ")
			.Append(info.ValidateValueMethodName)
			.Append(", ")
			.Append(info.PropertyChangedMethodName)
			.Append(", ")
			.Append(info.PropertyChangingMethodName)
			.Append(", ")
			.Append(info.CoerceValueMethodName)
			.Append(", ")
			.Append(info.DefaultValueCreatorMethodName)
			.Append(");\n\n");

		// Generate Get method
		if (info.GetterAccessibility is not null)
		{

			GenerateGetter(sb, info.EffectiveGetterMethodXmlDocumentation, info.GetterAccessibility, formattedReturnType, info.PropertyName, info.BindablePropertyName);
		}

		// Generate Set method
		if (info.SetterAccessibility is not null)
		{
			GenerateSetter(sb, info.EffectiveSetterMethodXmlDocumentation, info.SetterAccessibility, formattedReturnType, info.PropertyName, info.BindablePropertyName, info.BindablePropertyKeyName, info.IsReadOnlyBindableProperty);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static void GenerateGetter(in StringBuilder sb, in string getterMethodXmlDocumentation, in string getterAccessibility, in string returnType, in string propertyName, in string bindablePropertyName)
	{
		sb.Append(getterMethodXmlDocumentation)
			.Append("\r\n");

		sb.Append(getterAccessibility)
			.Append("static ")
			.Append(returnType)
			.Append(" Get")
			.Append(propertyName)
			.Append("(")
			.Append(bindableObjectFullName)
			.Append(" bindable) => (")
			.Append(returnType)
			.Append(")bindable.GetValue(")
			.Append(bindablePropertyName)
			.Append(");\n\n");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static void GenerateSetter(in StringBuilder sb, in string setterMethodXmlDocumentation, in string setterAccessibility, in string returnType, in string propertyName, in string bindablePropertyName, in string bindablePropertyKeyName, in bool isReadyOnlyBindableProperty)
	{
		sb.Append(setterMethodXmlDocumentation)
			.Append("\r\n");

		sb.Append(setterAccessibility)
			.Append("static void Set")
			.Append(propertyName)
			.Append("(")
			.Append(bindableObjectFullName)
			.Append(" bindable, ")
			.Append(returnType)
			.Append(" value) => bindable.SetValue(");

		if (isReadyOnlyBindableProperty)
		{
			sb.Append(bindablePropertyKeyName);
		}
		else
		{
			sb.Append(bindablePropertyName);
		}

		sb.Append(", value);\n\n");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static AttachedBindablePropertySemanticValues SemanticTransform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var classDeclarationSyntax = (ClassDeclarationSyntax)context.TargetNode;
		var semanticModel = context.SemanticModel;
		var classSymbol = (INamedTypeSymbol?)ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax, cancellationToken);

		if (classSymbol is null)
		{
			return emptyAttachedBindablePropertySemanticValues;
		}

		return ExtractAttachedBindableProperties(classSymbol, context.Attributes, cancellationToken);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static AttachedBindablePropertySemanticValues SemanticTransformConstructor(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var constructorDeclarationSyntax = (ConstructorDeclarationSyntax)context.TargetNode;
		var semanticModel = context.SemanticModel;
		var constructorSymbol = (IMethodSymbol?)ModelExtensions.GetDeclaredSymbol(semanticModel, constructorDeclarationSyntax, cancellationToken);

		if (constructorSymbol is null || constructorSymbol.ContainingType is null)
		{
			return emptyAttachedBindablePropertySemanticValues;
		}

		return ExtractAttachedBindableProperties(constructorSymbol.ContainingType, context.Attributes, cancellationToken);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static AttachedBindablePropertySemanticValues ExtractAttachedBindableProperties(INamedTypeSymbol classSymbol, ImmutableArray<AttributeData> attributes, CancellationToken cancellationToken)
	{
		var @namespace = classSymbol.ContainingNamespace.ToDisplayString();
		var className = classSymbol.Name;
		var classAccessibility = classSymbol.DeclaredAccessibility.ToString().ToLower();

		// Build containing types hierarchy
		var containingTypes = GetContainingTypes(classSymbol);

		// Extract generic type parameters
		var genericTypeParameters = GetGenericTypeParameters(classSymbol);

		var classInfo = new ClassInformation(className, classAccessibility, @namespace, containingTypes, genericTypeParameters);

		// Use array for attached bindable properties
		var attachedBindablePropertyModels = new AttachedBindablePropertyModel[attributes.Length];

		for (int i = 0; i < attributes.Length; i++)
		{
			var attributeData = attributes[i];
			attachedBindablePropertyModels[i] = CreateAttachedBindablePropertyModel(attributeData, classSymbol);
		}

		return new(classInfo, ImmutableArray.Create(attachedBindablePropertyModels).AsEquatableArray());
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static AttachedBindablePropertyModel CreateAttachedBindablePropertyModel(AttributeData attributeData, INamedTypeSymbol declaringType)
	{
		if (attributeData.AttributeClass is null || attributeData.ConstructorArguments.Length is 0)
		{
			throw new ArgumentException("Invalid attribute data");
		}

		// Get property name from constructor argument
		var propertyNameArg = attributeData.ConstructorArguments[0];
		var propertyName = propertyNameArg.Value as string ?? throw new InvalidOperationException("Property name must be a string");

		// Validate property name starts with uppercase
		if (string.IsNullOrEmpty(propertyName) || char.IsLower(propertyName[0]))
		{
			throw new NotSupportedException($"Property name '{propertyName}' must start with an uppercase letter cannot be empty");
		}

		// Get the generic type argument (the T in AttachedBindableProperty<T>)
		var typeArg = (attributeData.AttributeClass?.TypeArguments.FirstOrDefault()) ?? throw new InvalidOperationException("Could not determine property type from attribute");
		var isDeclaringTypeNullable = (bool)(attributeData.NamedArguments.SingleOrDefault(kvp => kvp.Key == "IsNullable").Value.Value ?? false);

		var defaultValue = GetDefaultValueString(attributeData, typeArg, AttachedBindablePropertyModel.ShouldPostpendNullableToType(typeArg, isDeclaringTypeNullable));
		var defaultBindingMode = attributeData.GetNamedTypeArgumentsAttributeValueForDefaultBindingMode("DefaultBindingMode", "(global::Microsoft.Maui.Controls.BindingMode)0");
		var validateValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("ValidateValueMethodName");
		var propertyChangedMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("PropertyChangedMethodName");
		var propertyChangingMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("PropertyChangingMethodName");
		var coerceValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("CoerceValueMethodName");
		var defaultValueCreatorMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("DefaultValueCreatorMethodName");

		var getterAccessibility = GetAccessibilityString(attributeData, "GetterAccessibility");
		var setterAccessibility = GetAccessibilityString(attributeData, "SetterAccessibility");
		var bindablePropertyAccessibility = GetAccessibilityString(attributeData, "BindablePropertyAccessibility")
											?? throw new InvalidOperationException("Bindable Property Accessibilty Cannot be null");

		var getterMethodXMLDocumentation = GetXMLDocumenation(attributeData, "GetterMethodXmlDocumentation");
		var setterMethodXMLDocumentation = GetXMLDocumenation(attributeData, "SetterMethodXmlDocumentation");
		var bindablePropertyXMLDocumentation = GetXMLDocumenation(attributeData, "BindablePropertyXmlDocumentation");

		var isReadOnly = GetIsReadOnlyBindableProperty(attributeData);

		return new AttachedBindablePropertyModel(
			propertyName,
			typeArg,
			declaringType,
			defaultValue,
			defaultBindingMode,
			validateValueMethodName,
			propertyChangedMethodName,
			propertyChangingMethodName,
			coerceValueMethodName,
			defaultValueCreatorMethodName,
			getterAccessibility,
			setterAccessibility,
			bindablePropertyAccessibility,
			isDeclaringTypeNullable,
			bindablePropertyXMLDocumentation,
			getterMethodXMLDocumentation,
			setterMethodXMLDocumentation,
			isReadOnly
		);
	}

	// DefaultValue can only be a primitive type, enum, typeof expression or array
	// In C#, attribute arguments are limited to compile-time constants, typeof expressions, and single-dimensional arrays
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetDefaultValueString(AttributeData attributeData, ITypeSymbol typeArg, bool shouldPostpendNullableSymbol)
	{
		var defaultValueArg = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key is "DefaultValue");

		if (defaultValueArg.Value.IsNull)
		{
			return "null";
		}

		var value = defaultValueArg.Value;

		// Handle Arrays
		if (typeArg.TypeKind is TypeKind.Array)
		{
			return GetFormattedArrayValue(value, GetFormattedReturnType(typeArg, shouldPostpendNullableSymbol));
		}

		// Handle null values
		if (value.Value is null)
		{
			return "null";
		}

		var typeSymbol = GetFormattedReturnType(typeArg, shouldPostpendNullableSymbol);

		return value.Value switch
		{
			// Handle char
			char charVal => $"({typeSymbol})'{charVal}'",

			// Handle string
			string stringVal => $"({typeSymbol})\"{GetEscapedString(stringVal)}\"",

			// Handle enums and all remaining compile-time constants
			_ => $"({typeSymbol}){GetFormattedConstantValue(value)}"
		};
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string? GetXMLDocumenation(AttributeData attributeData, string parameterName)
	{
		var xmlDocumentation = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key == parameterName)
			.Value;

		if (xmlDocumentation.IsNull || xmlDocumentation.Value is null)
		{
			return null;
		}

		return xmlDocumentation.Value.ToString();
	}

	static bool GetIsReadOnlyBindableProperty(AttributeData attributeData)
	{
		var accessibility = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key == "SetterAccessibility")
			.Value;

		if (accessibility.IsNull || accessibility.Value is null)
		{
			return false;
		}

		var enumValue = (int)accessibility.Value;

		return enumValue switch
		{
			0 => false, // Public
			1 => false, // Internal
			2 => false, // ProtectedInternal
			3 => true, // Protected
			4 => true, // PrivateProtected
			5 => true, // Private
			6 => true, // null
			_ => throw new NotSupportedException($"{accessibility.Value} is not yet supported")
		};
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string? GetAccessibilityString(AttributeData attributeData, string parameterName)
	{
		var accessibility = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key == parameterName)
			.Value;

		if (accessibility.IsNull || accessibility.Value is null)
		{
			return "public ";
		}

		var enumValue = (int)accessibility.Value;

		return enumValue switch
		{
			0 => "public ",
			1 => "internal ",
			2 => "protected internal ",
			3 => "protected ",
			4 => "private protected ",
			5 => "private ",
			6 => null,
			_ => throw new NotSupportedException($"{accessibility.Value} is not yet supported")
		};
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsNonEmptyClassDeclarationSyntax(SyntaxNode node, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsNonEmptyConstructorDeclarationSyntax(SyntaxNode node, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return node is ConstructorDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsDotnetKeyword(in string name) => SyntaxFacts.GetKeywordKind(name) is not SyntaxKind.None;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsGlobalNamespace(in ClassInformation classInformation) => classInformation.ContainingNamespace is "<global namespace>" or "";

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetContainingTypes(INamedTypeSymbol typeSymbol)
	{
		var current = typeSymbol.ContainingType;
		if (current is null)
		{
			return string.Empty;
		}

		var sb = new StringBuilder(100);
		var stack = new Stack<string>(4);

		while (current is not null)
		{
			stack.Push(current.Name);
			current = current.ContainingType;
		}

		var first = true;
		while (stack.Count > 0)
		{
			if (!first)
			{
				sb.Append('.');
			}

			sb.Append(stack.Pop());
			first = false;
		}

		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetGenericTypeParameters(INamedTypeSymbol typeSymbol)
	{
		if (!typeSymbol.IsGenericType || typeSymbol.TypeParameters.IsEmpty)
		{
			return string.Empty;
		}

		var typeParams = typeSymbol.TypeParameters;
		if (typeParams.Length is 1)
		{
			return typeParams[0].Name;
		}

		var sb = new StringBuilder(typeParams.Length * 10);
		for (int i = 0; i < typeParams.Length; i++)
		{
			if (i > 0)
			{
				sb.Append(", ");
			}

			sb.Append(typeParams[i].Name);
		}

		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static ITypeSymbol ConvertToNonNullableTypeSymbol(in ITypeSymbol typeSymbol)
	{
		// Check for Nullable<T>
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nullableType)
		{
			return nullableType.TypeArguments[0];
		}

		// Check for Nullable Reference Type
		if (typeSymbol.NullableAnnotation is NullableAnnotation.Annotated)
		{
			return typeSymbol.WithNullableAnnotation(NullableAnnotation.None);
		}

		return typeSymbol;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetFormattedReturnType(ITypeSymbol typeSymbol, bool shouldPostpendNullableSymbol)
	{
		var formattedType = GetFormattedTypeForTypeOf(typeSymbol);

		return shouldPostpendNullableSymbol ? $"{formattedType}?" : formattedType;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetFormattedTypeForTypeOf(ITypeSymbol typeSymbol)
	{
		if (typeSymbol is IArrayTypeSymbol arrayTypeSymbol)
		{
			string elementType = GetFormattedTypeForTypeOf(arrayTypeSymbol.ElementType);
			var rank = arrayTypeSymbol.Rank > 1 ? new string(',', arrayTypeSymbol.Rank - 1) : string.Empty;
			return string.Concat(elementType, "[", rank, "]");
		}

		return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetEscapedString(string value)
	{
		return value
			.Replace("\\", "\\\\")
			.Replace("\"", "\\\"")
			.Replace("\n", "\\n")
			.Replace("\r", "\\r")
			.Replace("\t", "\\t");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetFormattedArrayValue(TypedConstant arrayConstant, string typeSymbol)
	{
		if (arrayConstant.Values.Length is 0)
		{
			return $"({typeSymbol})[]";
		}

		// Single-dimensional array
		var sb = new StringBuilder();
		sb.Append("(").Append(typeSymbol).Append(")new[] { ");

		for (int i = 0; i < arrayConstant.Values.Length; i++)
		{
			if (i > 0)
			{
				sb.Append(", ");
			}

			var element = arrayConstant.Values[i];
			sb.Append(GetFormattedConstantValue(element));
		}

		sb.Append(" }");
		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static string GetFormattedConstantValue(TypedConstant constant)
	{
		if (constant.IsNull)
		{
			return "null";
		}

		return constant.Value switch
		{
			true => "true",
			false => "false",
			int intVal => intVal.ToString(),
			byte byteVal => byteVal.ToString(),
			sbyte sbyteVal => sbyteVal.ToString(),
			short shortVal => shortVal.ToString(),
			ushort ushortVal => ushortVal.ToString(),
			long longVal => $"{longVal}L",
			uint uintVal => $"{uintVal}U",
			ulong ulongVal => $"{ulongVal}UL",
			double doubleVal => doubleVal switch
			{
				double.NaN => "double.NaN",
				double.PositiveInfinity => "double.PositiveInfinity",
				double.NegativeInfinity => "double.NegativeInfinity",
				double.Epsilon => "double.Epsilon",
				double.MaxValue => "double.MaxValue",
				double.MinValue => "double.MinValue",
				_ => doubleVal.ToString("G17")
			},
			float floatVal => floatVal switch
			{
				float.NaN => "float.NaN",
				float.PositiveInfinity => "float.PositiveInfinity",
				float.NegativeInfinity => "float.NegativeInfinity",
				float.Epsilon => "float.Epsilon",
				float.MaxValue => "float.MaxValue",
				float.MinValue => "float.MinValue",
				_ => $"{floatVal:G9}f"
			},
			char charVal => $"'{charVal}'",
			string stringVal => $"\"{GetEscapedString(stringVal)}\"",
			_ => "null"
		};
	}
}