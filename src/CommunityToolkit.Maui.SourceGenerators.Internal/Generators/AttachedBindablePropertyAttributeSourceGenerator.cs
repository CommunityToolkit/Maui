using System.Collections.Immutable;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using CommunityToolkit.Maui.SourceGenerators.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CommunityToolkit.Maui.SourceGenerators.Internal;

[Generator]
public class AttachedBindablePropertyAttributeSourceGenerator : IIncrementalGenerator
{
	static readonly AttachedBindablePropertySemanticValues emptyAttachedBindablePropertySemanticValues = new(default, []);

	const string bindablePropertyFullName = "global::Microsoft.Maui.Controls.BindableProperty";
	const string bindableObjectFullName = "global::Microsoft.Maui.Controls.BindableObject";
	const string attachedBpAttribute =
		/* language=C#-test */
		//lang=csharp
		$$"""
		  // <auto-generated>
		  // See: CommunityToolkit.Maui.SourceGenerators.Internal.AttachedBindablePropertySourceGenerator

		  #pragma warning disable
		  #nullable enable
		  namespace CommunityToolkit.Maui;

		  [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
		  [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Constructor, AllowMultiple = true, Inherited = false)]
		  [global::System.Diagnostics.CodeAnalysis.Experimental("{{BindablePropertyDiagnostic.BindablePropertyAttributeExperimentalDiagnosticId}}")]
		  sealed partial class AttachedBindablePropertyAttribute<T>(string propertyName) : global::System.Attribute
		  {
		  	public string? PropertyName { get; } = propertyName;
		  	public global::System.Type? DeclaringType { get; init; }
		  	public global::Microsoft.Maui.Controls.BindingMode DefaultBindingMode { get; init; }
		  	public string ValidateValueMethodName { get; init; } = string.Empty;
		  	public string PropertyChangedMethodName { get; init; } = string.Empty;
		  	public string PropertyChangingMethodName { get; init; } = string.Empty;
		  	public string CoerceValueMethodName { get; init; } = string.Empty;
		  	public string DefaultValueCreatorMethodName { get; init; } = string.Empty;
		  	public global::Microsoft.CodeAnalysis.Accessibility GetterAccessibility { get; init; } = global::Microsoft.CodeAnalysis.Accessibility.Public;
		  	public global::Microsoft.CodeAnalysis.Accessibility SetterAccessibility { get; init; } = global::Microsoft.CodeAnalysis.Accessibility.Public;
		  }
		  """;

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
#if DEBUG
		if (!Debugger.IsAttached)
		{
			// To debug this SG, uncomment the line below and rebuild the SourceGenerator project.
			//Debugger.Launch();
		}
#endif

		context.RegisterPostInitializationOutput(static ctx => ctx.AddSource("AttachedBindablePropertyAttribute.g.cs", SourceText.From(attachedBpAttribute, Encoding.UTF8)));

		var classProvider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.AttachedBindablePropertyAttribute`1",
				IsNonEmptyClassDeclarationSyntax, SemanticTransform)
			.Where(static x => x.ClassInformation != default || !x.BindableProperties.IsEmpty)
			.Collect();

		var constructorProvider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.AttachedBindablePropertyAttribute`1",
				IsNonEmptyConstructorDeclarationSyntax, SemanticTransformConstructor)
			.Where(static x => x.ClassInformation != default || !x.BindableProperties.IsEmpty)
			.Collect();

		context.RegisterSourceOutput(classProvider, ExecuteAllValues);
		context.RegisterSourceOutput(constructorProvider, ExecuteAllValues);
	}

	static void ExecuteAllValues(SourceProductionContext context, ImmutableArray<AttachedBindablePropertySemanticValues> semanticValues)
	{
		// Pre-allocate dictionary with expected capacity
		var groupedValues = new Dictionary<(string, string, string, string), List<AttachedBindablePropertySemanticValues>>(semanticValues.Length);

		// Single-pass grouping without LINQ
		foreach (var sv in semanticValues)
		{
			var key = (sv.ClassInformation.ClassName, sv.ClassInformation.ContainingNamespace, sv.ClassInformation.ContainingTypes, sv.ClassInformation.GenericTypeParameters);

			if (!groupedValues.TryGetValue(key, out var list))
			{
				list = [];
				groupedValues[key] = list;
			}
			list.Add(sv);
		}

		// Use ArrayPool for temporary storage
		var attachedBindablePropertiesBuffer = System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Rent(32);

		try
		{
			foreach (var keyValuePair in groupedValues)
			{
				var (className, containingNamespace, containingTypes, genericTypeParameters) = keyValuePair.Key;
				var values = keyValuePair.Value;

				if (values.Count is 0 || string.IsNullOrEmpty(className) || string.IsNullOrEmpty(containingNamespace))
				{
					continue;
				}

				// Flatten attached bindable properties without SelectMany allocation
				var attachedBindablePropertiesCount = 0;
				foreach (var value in values)
				{
					foreach (var abp in value.BindableProperties.AsImmutableArray())
					{
						if (attachedBindablePropertiesCount >= attachedBindablePropertiesBuffer.Length)
						{
							var newBuffer = System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Rent(attachedBindablePropertiesBuffer.Length * 2);
							Array.Copy(attachedBindablePropertiesBuffer, newBuffer, attachedBindablePropertiesBuffer.Length);
							System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Return(attachedBindablePropertiesBuffer);
							attachedBindablePropertiesBuffer = newBuffer;
						}
						attachedBindablePropertiesBuffer[attachedBindablePropertiesCount++] = abp;
					}
				}

				var attachedBindableProperties = ImmutableArray.Create(attachedBindablePropertiesBuffer, 0, attachedBindablePropertiesCount);

				var classAccessibility = values[0].ClassInformation.DeclaredAccessibility;

				var combinedClassInfo = new ClassInformation(className, classAccessibility, containingNamespace, containingTypes, genericTypeParameters);
				var combinedValues = new AttachedBindablePropertySemanticValues(combinedClassInfo, attachedBindableProperties.AsEquatableArray());

				var fileNameSuffix = string.IsNullOrEmpty(containingTypes) ? className : string.Concat(containingTypes, ".", className);
				var source = GenerateSource(combinedValues);
				SourceStringService.FormatText(ref source);
				context.AddSource($"{fileNameSuffix}.g.cs", SourceText.From(source, Encoding.UTF8));
			}
		}
		finally
		{
			System.Buffers.ArrayPool<AttachedBindablePropertyModel>.Shared.Return(attachedBindablePropertiesBuffer);
		}
	}

	static string GenerateSource(AttachedBindablePropertySemanticValues value)
	{
		// Pre-calculate StringBuilder capacity to avoid resizing
		var estimatedCapacity = 500 + (value.BindableProperties.AsImmutableArray().Length * 500);
		var sb = new StringBuilder(estimatedCapacity);

		sb.Append("// <auto-generated>\n// See: CommunityToolkit.Maui.SourceGenerators.Internal.AttachedBindablePropertyAttributeSourceGenerator\n\n#pragma warning disable\n#nullable enable\n\n");

		if (!IsGlobalNamespace(value.ClassInformation))
		{
			sb.Append("namespace ").Append(value.ClassInformation.ContainingNamespace).Append(";\n\n");
		}

		// Generate nested class hierarchy
		if (!string.IsNullOrEmpty(value.ClassInformation.ContainingTypes))
		{
			var containingTypeNames = value.ClassInformation.ContainingTypes.Split('.');
			foreach (var typeName in containingTypeNames)
			{
				sb.Append(value.ClassInformation.DeclaredAccessibility).Append(" partial class ").Append(typeName).Append("\n{\n\n");
			}
		}

		// Get the class name with generic parameters
		var classNameWithGenerics = value.ClassInformation.ClassName;
		if (!string.IsNullOrEmpty(value.ClassInformation.GenericTypeParameters))
		{
			classNameWithGenerics = string.Concat(value.ClassInformation.ClassName, "<", value.ClassInformation.GenericTypeParameters, ">");
		}

		sb.Append(value.ClassInformation.DeclaredAccessibility).Append(" partial class ").Append(classNameWithGenerics).Append("\n{\n\n");

		// Build fully-qualified declaring type name
		var fullDeclaringType = BuildFullyQualifiedTypeName(value.ClassInformation, classNameWithGenerics);

		foreach (var info in value.BindableProperties.AsImmutableArray())
		{
			GenerateAttachedBindableProperty(sb, in info, fullDeclaringType);
		}

		sb.Append('}');

		// Close nested class hierarchy
		if (!string.IsNullOrEmpty(value.ClassInformation.ContainingTypes))
		{
			var containingTypeNames = value.ClassInformation.ContainingTypes.Split('.');
			for (int i = 0; i < containingTypeNames.Length; i++)
			{
				sb.Append("\n}");
			}
		}

		return sb.ToString();
	}

	static string BuildFullyQualifiedTypeName(ClassInformation classInfo, string classNameWithGenerics)
	{
		if (IsGlobalNamespace(classInfo))
		{
			return string.IsNullOrEmpty(classInfo.ContainingTypes)
				? classNameWithGenerics
				: $"{classInfo.ContainingTypes}.{classNameWithGenerics}";
		}

		return string.IsNullOrEmpty(classInfo.ContainingTypes)
			? $"{classInfo.ContainingNamespace}.{classNameWithGenerics}"
			: $"{classInfo.ContainingNamespace}.{classInfo.ContainingTypes}.{classNameWithGenerics}";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static void GenerateAttachedBindableProperty(StringBuilder sb, in AttachedBindablePropertyModel info, string fullDeclaringType)
	{
		// Sanitize the Return Type because Nullable Reference Types cannot be used in the `typeof()` operator
		var nonNullableReturnType = ConvertToNonNullableTypeSymbol(info.ReturnType);
		var sanitizedPropertyName = IsDotnetKeyword(info.PropertyName) ? string.Concat("@", info.PropertyName) : info.PropertyName;
		var formattedReturnType = GetFormattedReturnType(info.ReturnType);
		var nonNullableFormattedType = GetFormattedTypeForTypeOf(nonNullableReturnType);

		// Generate BindableProperty
		sb.Append("/// <summary>\r\n/// Attached BindableProperty for the ")
			.Append(sanitizedPropertyName)
			.Append(" property.\r\n/// </summary>\r\n");

		sb.Append("public static readonly ")
			.Append(bindablePropertyFullName)
			.Append(" ")
			.Append(info.BindablePropertyName)
			.Append(" = ")
			.Append(bindablePropertyFullName)
			.Append(".CreateAttached(\"")
			.Append(sanitizedPropertyName)
			.Append("\", typeof(")
			.Append(nonNullableFormattedType)
			.Append("), typeof(")
			.Append(fullDeclaringType)
			.Append("), ")
			.Append(info.DefaultValue)
			.Append(", ")
			.Append(info.DefaultBindingMode)
			.Append(", ")
			.Append(info.ValidateValueMethodName)
			.Append(", ")
			.Append(info.PropertyChangedMethodName)
			.Append(", ")
			.Append(info.PropertyChangingMethodName)
			.Append(", ")
			.Append(info.CoerceValueMethodName)
			.Append(", ")
			.Append(info.DefaultValueCreatorMethodName)
			.Append(");\n\n");

		// Generate Get method
		if (info.GetterAccessibility != "NotApplicable")
		{
			sb.Append("/// <summary>\r\n/// Gets ")
				.Append(sanitizedPropertyName)
				.Append(" for the <paramref = \"bindable\"/> child element.\r\n/// </summary>\r\n");

			sb.Append(info.GetterAccessibility)
				.Append("static ")
				.Append(formattedReturnType)
				.Append(" Get")
				.Append(info.PropertyName)
				.Append("(")
				.Append(bindableObjectFullName)
				.Append(" bindable) => (")
				.Append(formattedReturnType)
				.Append(")bindable.GetValue(")
				.Append(info.BindablePropertyName)
				.Append(");\n\n");
		}

		// Generate Set method
		if (info.SetterAccessibility != "NotApplicable")
		{
			sb.Append("/// <summary>\r\n/// Sets ")
				.Append(sanitizedPropertyName)
				.Append(" for the <paramref = \"bindable\"/> child element.\r\n/// </summary>\r\n");

			sb.Append(info.SetterAccessibility)
				.Append("static void Set")
				.Append(info.PropertyName)
				.Append("(")
				.Append(bindableObjectFullName)
				.Append(" bindable, ")
				.Append(formattedReturnType)
				.Append(" value) => bindable.SetValue(")
				.Append(info.BindablePropertyName)
				.Append(", value);\n\n");
		}
	}

	static AttachedBindablePropertySemanticValues SemanticTransform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var classDeclarationSyntax = (ClassDeclarationSyntax)context.TargetNode;
		var semanticModel = context.SemanticModel;
		var classSymbol = (INamedTypeSymbol?)ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax, cancellationToken);

		if (classSymbol is null)
		{
			return emptyAttachedBindablePropertySemanticValues;
		}

		return ExtractAttachedBindableProperties(classSymbol, context.Attributes, cancellationToken);
	}

	static AttachedBindablePropertySemanticValues SemanticTransformConstructor(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var constructorDeclarationSyntax = (ConstructorDeclarationSyntax)context.TargetNode;
		var semanticModel = context.SemanticModel;
		var constructorSymbol = (IMethodSymbol?)ModelExtensions.GetDeclaredSymbol(semanticModel, constructorDeclarationSyntax, cancellationToken);

		if (constructorSymbol is null || constructorSymbol.ContainingType is null)
		{
			return emptyAttachedBindablePropertySemanticValues;
		}

		return ExtractAttachedBindableProperties(constructorSymbol.ContainingType, context.Attributes, cancellationToken);
	}

	static AttachedBindablePropertySemanticValues ExtractAttachedBindableProperties(INamedTypeSymbol classSymbol, ImmutableArray<AttributeData> attributes, CancellationToken cancellationToken)
	{
		var @namespace = classSymbol.ContainingNamespace.ToDisplayString();
		var className = classSymbol.Name;
		var classAccessibility = classSymbol.DeclaredAccessibility.ToString().ToLower();

		// Build containing types hierarchy
		var containingTypes = GetContainingTypes(classSymbol);

		// Extract generic type parameters
		var genericTypeParameters = GetGenericTypeParameters(classSymbol);

		var classInfo = new ClassInformation(className, classAccessibility, @namespace, containingTypes, genericTypeParameters);

		// Use array for attached bindable properties
		var attachedBindablePropertyModels = new AttachedBindablePropertyModel[attributes.Length];

		for (int i = 0; i < attributes.Length; i++)
		{
			var attributeData = attributes[i];
			attachedBindablePropertyModels[i] = CreateAttachedBindablePropertyModel(attributeData, classSymbol);
		}

		return new(classInfo, ImmutableArray.Create(attachedBindablePropertyModels).AsEquatableArray());
	}

	static AttachedBindablePropertyModel CreateAttachedBindablePropertyModel(AttributeData attributeData, INamedTypeSymbol declaringType)
	{
		if (attributeData.AttributeClass is null || attributeData.ConstructorArguments.Length == 0)
		{
			throw new ArgumentException("Invalid attribute data");
		}

		// Get property name from constructor argument
		var propertyNameArg = attributeData.ConstructorArguments[0];
		var propertyName = propertyNameArg.Value as string ?? throw new InvalidOperationException("Property name must be a string");

		// Validate property name starts with uppercase
		if (string.IsNullOrEmpty(propertyName) || char.IsLower(propertyName[0]))
		{
			throw new NotSupportedException($"Property name '{propertyName}' must start with an uppercase letter");
		}

		// Get the generic type argument (the T in AttachedBindableProperty<T>)
		var typeArg = (attributeData.AttributeClass as INamedTypeSymbol)?.TypeArguments.FirstOrDefault();
		if (typeArg is null)
		{
			throw new InvalidOperationException("Could not determine property type from attribute");
		}

		var defaultValue = GetDefaultValueString(attributeData, typeArg);
		var defaultBindingMode = attributeData.GetNamedTypeArgumentsAttributeValueForDefaultBindingMode("DefaultBindingMode", "Microsoft.Maui.Controls.BindingMode.OneWay");
		var validateValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("ValidateValueMethodName");
		var propertyChangedMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("PropertyChangedMethodName");
		var propertyChangingMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("PropertyChangingMethodName");
		var coerceValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("CoerceValueMethodName");
		var defaultValueCreatorMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString("DefaultValueCreatorMethodName");

		var getterAccessibility = GetAccessibilityString(attributeData, "GetterAccessibility", "public ");
		var setterAccessibility = GetAccessibilityString(attributeData, "SetterAccessibility", "public ");

		return new AttachedBindablePropertyModel(
			propertyName,
			typeArg,
			declaringType,
			defaultValue,
			defaultBindingMode,
			validateValueMethodName,
			propertyChangedMethodName,
			propertyChangingMethodName,
			coerceValueMethodName,
			defaultValueCreatorMethodName,
			getterAccessibility,
			setterAccessibility
		);
	}

	static string GetDefaultValueString(AttributeData attributeData, ITypeSymbol typeArg)
	{
		var defaultValueArg = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key == "DefaultValue");

		if (defaultValueArg.Value.IsNull)
		{
			return "null";
		}

		var value = defaultValueArg.Value;

		// Handle null values
		if (value.Value is null)
		{
			return "null";
		}

		// Format based on the value type
		var typeSymbol = GetFormattedReturnType(typeArg);

		return value.Value switch
		{
			// Primitive types with casting
			true => $"(bool)true",
			false => $"(bool)false",
			int intVal => $"({typeSymbol}){intVal}",
			long longVal => $"({typeSymbol}){longVal}",
			double doubleVal => doubleVal switch
			{
				double.NaN => "(double)double.NaN",
				double.PositiveInfinity => "(double)double.PositiveInfinity",
				double.NegativeInfinity => "(double)double.NegativeInfinity",
				double.Epsilon => "(double)double.Epsilon",
				double.MaxValue => "(double)double.MaxValue",
				double.MinValue => "(double)double.MinValue",
				_ => $"({typeSymbol}){doubleVal:G17}"
			},
			float floatVal => floatVal switch
			{
				float.NaN => "(float)float.NaN",
				float.PositiveInfinity => "(float)float.PositiveInfinity",
				float.NegativeInfinity => "(float)float.NegativeInfinity",
				float.Epsilon => "(float)float.Epsilon",
				float.MaxValue => "(float)float.MaxValue",
				float.MinValue => "(float)float.MinValue",
				_ => $"({typeSymbol}){floatVal:G9}"
			},
			char charVal => $"({typeSymbol})'{charVal}'",
			string stringVal => $"({typeSymbol})\"{stringVal}\"",
			_ => "null"
		};
	}

	static string GetAccessibilityString(AttributeData attributeData, string parameterName, string defaultValue)
	{
		var accessibility = attributeData.NamedArguments
			.FirstOrDefault(x => x.Key == parameterName)
			.Value;

		if (accessibility.IsNull || accessibility.Value is null)
		{
			return defaultValue;
		}

		return (Accessibility)accessibility.Value switch
		{
			Accessibility.NotApplicable => "NotApplicable",
			Accessibility.Public => "public ",
			Accessibility.Private => "private ",
			Accessibility.Protected => "protected ",
			Accessibility.Internal => "internal ",
			Accessibility.ProtectedOrInternal => "protected internal ",
			Accessibility.ProtectedAndInternal => "private protected ",
			_ => defaultValue
		};
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsNonEmptyClassDeclarationSyntax(SyntaxNode node, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsNonEmptyConstructorDeclarationSyntax(SyntaxNode node, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();
		return node is ConstructorDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsDotnetKeyword(in string name) => SyntaxFacts.GetKeywordKind(name) is not SyntaxKind.None;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static bool IsGlobalNamespace(in ClassInformation classInformation) => classInformation.ContainingNamespace is "<global namespace>" or "";

	static string GetContainingTypes(INamedTypeSymbol typeSymbol)
	{
		var current = typeSymbol.ContainingType;
		if (current is null)
		{
			return string.Empty;
		}

		var sb = new StringBuilder(100);
		var stack = new Stack<string>(4);

		while (current is not null)
		{
			stack.Push(current.Name);
			current = current.ContainingType;
		}

		var first = true;
		while (stack.Count > 0)
		{
			if (!first)
			{
				sb.Append('.');
			}
			sb.Append(stack.Pop());
			first = false;
		}

		return sb.ToString();
	}

	static string GetGenericTypeParameters(INamedTypeSymbol typeSymbol)
	{
		if (!typeSymbol.IsGenericType || typeSymbol.TypeParameters.IsEmpty)
		{
			return string.Empty;
		}

		var typeParams = typeSymbol.TypeParameters;
		if (typeParams.Length == 1)
		{
			return typeParams[0].Name;
		}

		var sb = new StringBuilder(typeParams.Length * 10);
		for (int i = 0; i < typeParams.Length; i++)
		{
			if (i > 0)
			{
				sb.Append(", ");
			}
			sb.Append(typeParams[i].Name);
		}

		return sb.ToString();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static ITypeSymbol ConvertToNonNullableTypeSymbol(in ITypeSymbol typeSymbol)
	{
		// Check for Nullable<T>
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nullableType)
		{
			return nullableType.TypeArguments[0];
		}

		// Check for Nullable Reference Type
		if (typeSymbol.NullableAnnotation is NullableAnnotation.Annotated)
		{
			return typeSymbol.WithNullableAnnotation(NullableAnnotation.None);
		}

		return typeSymbol;
	}

	static string GetFormattedReturnType(ITypeSymbol typeSymbol)
	{
		if (typeSymbol is IArrayTypeSymbol arrayTypeSymbol)
		{
			string elementType = GetFormattedReturnType(arrayTypeSymbol.ElementType);
			var rank = arrayTypeSymbol.Rank > 1 ? new string(',', arrayTypeSymbol.Rank - 1) : string.Empty;
			return string.Concat(elementType, "[", rank, "]");
		}

		// Handle Nullable<T> - display as T?
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nullableType)
		{
			var innerType = nullableType.TypeArguments[0];
			var formattedInner = GetFormattedReturnType(innerType);
			return $"{formattedInner}? ";
		}

		return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
	}

	static string GetFormattedTypeForTypeOf(ITypeSymbol typeSymbol)
	{
		if (typeSymbol is IArrayTypeSymbol arrayTypeSymbol)
		{
			string elementType = GetFormattedTypeForTypeOf(arrayTypeSymbol.ElementType);
			var rank = arrayTypeSymbol.Rank > 1 ? new string(',', arrayTypeSymbol.Rank - 1) : string.Empty;
			return string.Concat(elementType, "[", rank, "]");
		}

		return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
	}
}