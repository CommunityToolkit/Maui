using System.Collections.Immutable;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using CommunityToolkit.Maui.SourceGenerators.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CommunityToolkit.Maui.SourceGenerators.Internal;

[Generator]
public class BindablePropertyAttributeSourceGenerator : IIncrementalGenerator
{
	static readonly SemanticValues emptySemanticValues = new(default, []); 

	const string bpFullName = "global::Microsoft.Maui.Controls.BindableProperty";
	const string bpKeyFullName = "global::Microsoft.Maui.Controls.BindablePropertyKey";

	const string bpAttribute =
		/* language=C#-test */
		//lang=csharp
		$$"""
		  // <auto-generated>
		  // See: CommunityToolkit.Maui.SourceGenerators.Internal.BindablePropertyAttributeSourceGenerator

		  #pragma warning disable
		  #nullable enable
		  namespace CommunityToolkit.Maui;

		  [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
		  [global::System.AttributeUsage(global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
		  sealed partial class BindablePropertyAttribute : global::System.Attribute
		  {
		  	public string? PropertyName { get; }
		  	public global::System.Type? DeclaringType { get; set; }
		  	public object? DefaultValue { get; set; }
		  	public global::Microsoft.Maui.Controls.BindingMode DefaultBindingMode { get; set; }
		  	public string ValidateValueMethodName { get; set; } = string.Empty;
		  	public string PropertyChangedMethodName { get; set; } = string.Empty;
		  	public string PropertyChangingMethodName { get; set; } = string.Empty;
		  	public string CoerceValueMethodName { get; set; } = string.Empty;
		  	public string DefaultValueCreatorMethodName { get; set; } = string.Empty;
		  }
		  """;

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
#if DEBUG

		if (!Debugger.IsAttached)
		{
			// To debug this SG, uncomment the line below and rebuild the SourceGenerator project.

			//Debugger.Launch();
		}
#endif

		context.RegisterPostInitializationOutput(static ctx => ctx.AddSource("BindablePropertyAttribute.g.cs", SourceText.From(bpAttribute, Encoding.UTF8)));

		var provider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.BindablePropertyAttribute",
				IsNonEmptyPropertyDeclarationSyntax, SemanticTransform)
			.Where(static x => x.ClassInformation != default || !x.BindableProperties.IsEmpty)
			.Collect();


		context.RegisterSourceOutput(provider, ExecuteAllValues);
	}

	static void ExecuteAllValues(SourceProductionContext context, ImmutableArray<SemanticValues> semanticValues)
	{
		var groupedValues = semanticValues
			.GroupBy(static sv => (sv.ClassInformation.ClassName, sv.ClassInformation.ContainingNamespace, sv.ClassInformation.ContainingTypes, sv.ClassInformation.GenericTypeParameters))
			.ToDictionary(static d => d.Key, static d => d.ToArray());

		foreach (var keyValuePair in groupedValues)
		{
			var (className, containingNamespace, containingTypes, genericTypeParameters) = keyValuePair.Key;
			var values = keyValuePair.Value;

			if (values.Length is 0 || string.IsNullOrEmpty(className) || string.IsNullOrEmpty(containingNamespace))
			{
				continue;
			}

			var bindableProperties = values.SelectMany(static x => x.BindableProperties).ToImmutableArray();

			var classAccessibility = values[0].ClassInformation.DeclaredAccessibility;

			var combinedClassInfo = new ClassInformation(className, classAccessibility, containingNamespace, containingTypes, genericTypeParameters);
			var combinedValues = new SemanticValues(combinedClassInfo, bindableProperties);

			var fileNameSuffix = string.IsNullOrEmpty(containingTypes) ? className : $"{containingTypes}.{className}";
			var source = GenerateSource(combinedValues);
			SourceStringService.FormatText(ref source);
			context.AddSource($"{fileNameSuffix}.g.cs", SourceText.From(source, Encoding.UTF8));
		}
	}


	static string GenerateSource(SemanticValues value)
	{
		var namespaceLine = IsGlobalNamespace(value.ClassInformation)
			? string.Empty
			: $"namespace {value.ClassInformation.ContainingNamespace};";

		var sb = new StringBuilder(
			/* language=C#-test */
			//lang=csharp
			$"""
			  // <auto-generated>
			  // See: CommunityToolkit.Maui.SourceGenerators.Internal.BindablePropertyAttributeSourceGenerator

			  #pragma warning disable
			  #nullable enable

			  {namespaceLine}

			  """);

		// Generate nested class hierarchy
		if (!string.IsNullOrEmpty(value.ClassInformation.ContainingTypes))
		{
			var containingTypeNames = value.ClassInformation.ContainingTypes.Split('.');
			foreach (var typeName in containingTypeNames)
			{
				sb.AppendLine($"{value.ClassInformation.DeclaredAccessibility} partial class {typeName}")
					.AppendLine("{")
					.AppendLine();
			}
		}

		// Get the class name with generic parameters
		var classNameWithGenerics = value.ClassInformation.ClassName;
		if (!string.IsNullOrEmpty(value.ClassInformation.GenericTypeParameters))
		{
			classNameWithGenerics = $"{value.ClassInformation.ClassName}<{value.ClassInformation.GenericTypeParameters}>";
		}

		sb.AppendLine($"{value.ClassInformation.DeclaredAccessibility} partial class {classNameWithGenerics}")
			.AppendLine("{")
			.AppendLine();

		foreach (var info in value.BindableProperties)
		{
			GenerateBindableProperty(ref sb, info);
			GenerateProperty(ref sb, info);
		}

		sb.Append('}');

		// Close nested class hierarchy
		if (!string.IsNullOrEmpty(value.ClassInformation.ContainingTypes))
		{
			var containingTypeNames = value.ClassInformation.ContainingTypes.Split('.');
			for (int i = 0; i < containingTypeNames.Length; i++)
			{
				sb.AppendLine().Append('}');
			}
		}

		return sb.ToString();

		static void GenerateBindableProperty(ref readonly StringBuilder sb, in BindablePropertyModel info)
		{
			// Sanitize the Return Type because Nullable Reference Types cannot be used in the `typeof()` operator
			var nonNullableReturnType = ConvertToNonNullableTypeSymbol(info.ReturnType);
			var sanitizedPropertyName = IsDotnetKeyword(info.PropertyName) ? "@" + info.PropertyName : info.PropertyName;

			/*
			// The code below creates the following XML Tag:
			/// <summary>
			/// Backing BindableProperty for the <see cref="PropertyName"/> property.
			/// </summary>
			*/
			sb.AppendLine("/// <summary>")
				.AppendLine($"/// Backing BindableProperty for the <see cref=\"{sanitizedPropertyName}\"/> property.")
				.AppendLine("/// </summary>");

			// Determine if we should generate a read-only BindableProperty (BindablePropertyKey).
			// Create a read-only bindable when the property doesn't have a setter or has a non-public setter.
			// This ensures read-only protection is maintained.
			var shouldCreateReadOnly = !info.HasSetter || !string.IsNullOrEmpty(info.SetterAccessibilityText);

			if (shouldCreateReadOnly)
			{
				// Create name for the BindablePropertyKey (camel-cased first letter to follow existing pattern)
				var propertyKeyName = !string.IsNullOrEmpty(info.PropertyName)
					? $"{char.ToLower(info.PropertyName[0])}{info.PropertyName[1..]}PropertyKey"
					: "propertyKeyPropertyKey";

				sb.AppendLine($"static readonly {bpKeyFullName} {propertyKeyName} = ")
					.Append($"{bpFullName}.CreateReadOnly(")
					.Append($"\"{sanitizedPropertyName}\", ")
					.Append($"typeof({GetFormattedReturnType(nonNullableReturnType)}), ")
					.Append($"typeof({info.DeclaringType}), ")
					.Append($"{info.DefaultValue}, ")
					.Append($"{info.DefaultBindingMode}, ")
					.Append($"{info.ValidateValueMethodName}, ")
					.Append($"{info.PropertyChangedMethodName}, ")
					.Append($"{info.PropertyChangingMethodName}, ")
					.Append($"{info.CoerceValueMethodName}, ")
					.Append($"{info.DefaultValueCreatorMethodName}")
					.Append(");")
					.AppendLine()
					.AppendLine($"public {info.NewKeywordText}static readonly {bpFullName} {info.BindablePropertyName} = {propertyKeyName}.BindableProperty;")
					.AppendLine();
			}
			else
			{
				sb.AppendLine($"public {info.NewKeywordText}static readonly {bpFullName} {info.BindablePropertyName} = ")
					.Append($"{bpFullName}.Create(")
					.Append($"\"{sanitizedPropertyName}\", ")
					.Append($"typeof({GetFormattedReturnType(nonNullableReturnType)}), ")
					.Append($"typeof({info.DeclaringType}), ")
					.Append($"{info.DefaultValue}, ")
					.Append($"{info.DefaultBindingMode}, ")
					.Append($"{info.ValidateValueMethodName}, ")
					.Append($"{info.PropertyChangedMethodName}, ")
					.Append($"{info.PropertyChangingMethodName}, ")
					.Append($"{info.CoerceValueMethodName}, ")
					.Append($"{info.DefaultValueCreatorMethodName}")
					.Append(");")
					.AppendLine().AppendLine();
			}
		}

		static void GenerateProperty(ref readonly StringBuilder sb, in BindablePropertyModel info)
		{
			// The code below creates the following Property:
			//
			//	public partial string Text
			//	{
			//		get => (string)GetValue(TextProperty);
			//		set => SetValue(TextProperty, value);
			//	}
			//
			var sanitizedPropertyName = IsDotnetKeyword(info.PropertyName) ? "@" + info.PropertyName : info.PropertyName;

			sb.AppendLine($"public {info.NewKeywordText}partial {GetFormattedReturnType(info.ReturnType)} {sanitizedPropertyName}")
				.AppendLine("{")
				.Append("get => (")
				.Append(GetFormattedReturnType(info.ReturnType))
				.Append(")GetValue(")
				.AppendLine($"{info.BindablePropertyName});");

			// Generate setter only when the original property had a setter.
			if (info.HasSetter)
			{
				if (!string.IsNullOrEmpty(info.SetterAccessibilityText))
				{
					// non-public setter -> set value via the BindablePropertyKey (keep setter accessibility)
					// Calculate the property key name the same way as in GenerateBindableProperty
					var propertyKeyName = !string.IsNullOrEmpty(info.PropertyName)
						? $"{char.ToLower(info.PropertyName[0])}{info.PropertyName[1..]}PropertyKey"
						: "propertyKeyPropertyKey";
					sb.Append($"{info.SetterAccessibilityText}set => SetValue(")
						.AppendLine($"{propertyKeyName}, value);");
				}
				else
				{
					// public setter -> set via BindableProperty
					sb.Append($"set => SetValue(")
						.AppendLine($"{info.BindablePropertyName}, value);");
				}
			}

			sb.AppendLine("}");
		}
	}

	static SemanticValues SemanticTransform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var propertyDeclarationSyntax = Unsafe.As<PropertyDeclarationSyntax>(context.TargetNode);
		var semanticModel = context.SemanticModel;
		var propertySymbol = (IPropertySymbol?)ModelExtensions.GetDeclaredSymbol(semanticModel, propertyDeclarationSyntax, cancellationToken);

		if (propertySymbol is null)
		{
			return emptySemanticValues;
		}

		var @namespace = propertySymbol.ContainingNamespace.ToDisplayString();
		var className = propertySymbol.ContainingType.Name;
		var classAccessibility = propertySymbol.ContainingSymbol.DeclaredAccessibility.ToString().ToLower();
		var returnType = propertySymbol.Type;

		// Build containing types hierarchy
		var containingTypes = GetContainingTypes(propertySymbol.ContainingType);

		// Extract generic type parameters
		var genericTypeParameters = GetGenericTypeParameters(propertySymbol.ContainingType);

		var propertyInfo = new ClassInformation(className, classAccessibility, @namespace, containingTypes, genericTypeParameters);

		var bindablePropertyModels = new List<BindablePropertyModel>(context.Attributes.Length);

		var doesContainNewKeyword = propertyDeclarationSyntax.Modifiers.Any(static x => x.IsKind(SyntaxKind.NewKeyword));

		var attributeData = context.Attributes[0];

		// Determine setter accessibility and presence
		var setMethod = propertySymbol.SetMethod;
		// hasSetterAny indicates whether the property declaration included a setter (any accessibility)
		var hasSetterAny = setMethod is not null;
		// Keep the setter accessibility text for non-public setters ("internal ", "private ", etc.)
		string setterAccessibilityText = string.Empty;
		if (setMethod is not null && setMethod.DeclaredAccessibility != Accessibility.Public)
		{
			setterAccessibilityText = setMethod.DeclaredAccessibility.ToString().ToLower() + " ";
		}

		// Pass hasSetterAny to the model so the generated partial property includes a setter when the original declared one.
		bindablePropertyModels.Add(CreateBindablePropertyModel(attributeData, propertySymbol.ContainingType, propertySymbol.Name, returnType, doesContainNewKeyword, hasSetterAny, setterAccessibilityText));

		return new(propertyInfo, bindablePropertyModels.ToImmutableArray());
	}

	// Updated signature to accept setter info
	static BindablePropertyModel CreateBindablePropertyModel(in AttributeData attributeData, in INamedTypeSymbol declaringType, in string propertyName, in ITypeSymbol returnType, in bool doesContainNewKeyword, bool hasSetter, string setterAccessibilityText)
	{
		if (attributeData.AttributeClass is null)
		{
			throw new ArgumentException($"{nameof(attributeData.AttributeClass)} Cannot Be Null", nameof(attributeData.AttributeClass));
		}

		var defaultValue = attributeData.GetNamedTypeArgumentsAttributeValueByNameAsCastedString(nameof(BindablePropertyModel.DefaultValue), returnType);
		var coerceValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.CoerceValueMethodName));
		var defaultBindingMode = attributeData.GetNamedTypeArgumentsAttributeValueByNameAsCastedString(nameof(BindablePropertyModel.DefaultBindingMode), "Microsoft.Maui.Controls.BindingMode.OneWay");
		var defaultValueCreatorMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.DefaultValueCreatorMethodName));
		var propertyChangedMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.PropertyChangedMethodName));
		var propertyChangingMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.PropertyChangingMethodName));
		var validateValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.ValidateValueMethodName));
		var newKeywordText = doesContainNewKeyword ? "new " : string.Empty;

		return new BindablePropertyModel(propertyName, returnType, declaringType, defaultValue, defaultBindingMode, validateValueMethodName, propertyChangedMethodName, propertyChangingMethodName, coerceValueMethodName, defaultValueCreatorMethodName, newKeywordText, hasSetter, setterAccessibilityText);
	}

	static ITypeSymbol ConvertToNonNullableTypeSymbol(in ITypeSymbol typeSymbol)
	{
		// Check for Nullable<T>
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T })
		{
			return typeSymbol;
		}

		// Check for Nullable Reference Type
		if (typeSymbol.NullableAnnotation is NullableAnnotation.Annotated)
		{
			// For reference types, NullableAnnotation.None indicates non-nullable.
			return typeSymbol.WithNullableAnnotation(NullableAnnotation.None);
		}

		return typeSymbol;
	}

	static bool IsNonEmptyPropertyDeclarationSyntax(SyntaxNode node, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();

		return node is PropertyDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	static bool IsDotnetKeyword(in string name) => SyntaxFacts.GetKeywordKind(name) is not SyntaxKind.None;

	static bool IsGlobalNamespace(in ClassInformation classInformation)
	{
		if (classInformation.ContainingNamespace is "<global namespace>")
		{
			return true;
		}
		return false;
	}

	static string GetFormattedReturnType(ITypeSymbol typeSymbol)
	{
		if (typeSymbol is IArrayTypeSymbol arrayTypeSymbol)
		{
			// Get the element type name (e.g., "System.Int32")
			string elementType = GetFormattedReturnType(arrayTypeSymbol.ElementType);

			// Construct the correct rank syntax with commas (e.g., "[,]")
			string rank = new(',', arrayTypeSymbol.Rank - 1);

			return $"{elementType}[{rank}]";
		}
		else
		{
			// Use FullyQualifiedFormat to get fully qualified names with global:: prefix
			var fullyQualified = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			
			var formatted = fullyQualified.StartsWith("global::") 
				? fullyQualified["global::".Length..] 
				: fullyQualified;

			// If this is a Nullable<T> (value type) do not append an extra '?'
			if (typeSymbol is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T })
			{
				return formatted;
			}

			// If this is a nullable reference type (annotated with ?), ToDisplayString does not include
			// the trailing `?`, so add it explicitly. For Nullable<T> (value types) and arrays this
			// is handled elsewhere or by the display string itself.
			if (typeSymbol.NullableAnnotation is NullableAnnotation.Annotated)
			{
				formatted += "?";
			}

			return formatted;
		}
	}

	static string GetGenericTypeParameters(INamedTypeSymbol typeSymbol)
	{
		if (typeSymbol is null || typeSymbol.TypeParameters.Length == 0)
		{
			return string.Empty;
		}

		return string.Join(", ", typeSymbol.TypeParameters.Select(tp => tp.Name));
	}

	static string GetContainingTypes(INamedTypeSymbol? typeSymbol)
	{
		if (typeSymbol is null || typeSymbol.ContainingType is null)
		{
			return string.Empty;
		}

		var containingTypes = new Stack<string>();
		var currentType = typeSymbol.ContainingType;

		while (currentType is not null)
		{
			containingTypes.Push(currentType.Name);
			currentType = currentType.ContainingType;
		}

		return string.Join(".", containingTypes);
	}
}