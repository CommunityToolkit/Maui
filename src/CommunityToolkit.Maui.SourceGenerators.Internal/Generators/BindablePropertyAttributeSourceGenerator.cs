using System.Collections.Immutable;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using CommunityToolkit.Maui.SourceGenerators.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Helpers;
using CommunityToolkit.Maui.SourceGenerators.Internal.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CommunityToolkit.Maui.SourceGenerators.Internal;

[Generator]
public class BindablePropertyAttributeSourceGenerator : IIncrementalGenerator
{
	static readonly SemanticValues emptySemanticValues = new(default, []);

	const string bpFullName = "global::Microsoft.Maui.Controls.BindableProperty";

	const string bpAttribute =
		/* language=C#-test */
		//lang=csharp
		$$"""
		  // <auto-generated>
		  // See: CommunityToolkit.Maui.SourceGenerators.Internal.BindablePropertyAttributeSourceGenerator

		  #pragma warning disable
		  #nullable enable
		  namespace CommunityToolkit.Maui;

		  [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
		  [global::System.AttributeUsage(global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
		  sealed partial class BindablePropertyAttribute : global::System.Attribute
		  {
		  	public string? PropertyName { get; }
		  	public global::System.Type? DeclaringType { get; set; }
		  	public object? DefaultValue { get; set; }
		  	public global::Microsoft.Maui.Controls.BindingMode DefaultBindingMode { get; set; }
		  	public string ValidateValueMethodName { get; set; } = string.Empty;
		  	public string PropertyChangedMethodName { get; set; } = string.Empty;
		  	public string PropertyChangingMethodName { get; set; } = string.Empty;
		  	public string CoerceValueMethodName { get; set; } = string.Empty;
		  	public string DefaultValueCreatorMethodName { get; set; } = string.Empty;
		  }
		  """;

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
#if DEBUG

		if (!Debugger.IsAttached)
		{
			// To debug this SG, uncomment the line below and rebuild the SourceGenerator project.

			//Debugger.Launch();
		}
#endif

		context.RegisterPostInitializationOutput(static ctx => ctx.AddSource("BindablePropertyAttribute.g.cs", SourceText.From(bpAttribute, Encoding.UTF8)));

		var provider = context.SyntaxProvider.ForAttributeWithMetadataName("CommunityToolkit.Maui.BindablePropertyAttribute",
				IsNonEmptyPropertyDeclarationSyntax, SemanticTransform)
			.Where(static x => x.ClassInformation != default || !x.BindableProperties.IsEmpty)
			.Collect();


		context.RegisterSourceOutput(provider, ExecuteAllValues);
	}

	static void ExecuteAllValues(SourceProductionContext context, ImmutableArray<SemanticValues> semanticValues)
	{
		var groupedValues = semanticValues
			.GroupBy(static sv => (sv.ClassInformation.ClassName, sv.ClassInformation.ContainingNamespace))
			.ToDictionary(static d => d.Key, static d => d.ToArray());

		foreach (var keyValuePair in groupedValues)
		{
			var (className, containingNamespace) = keyValuePair.Key;
			var values = keyValuePair.Value;

			if (values.Length is 0 || string.IsNullOrEmpty(className) || string.IsNullOrEmpty(containingNamespace))
			{
				continue;
			}

			var bindableProperties = values.SelectMany(static x => x.BindableProperties).ToImmutableArray();

			var classAccessibility = values[0].ClassInformation.DeclaredAccessibility;

			var combinedClassInfo = new ClassInformation(className, classAccessibility, containingNamespace);
			var combinedValues = new SemanticValues(combinedClassInfo, bindableProperties);

			var source = GenerateSource(combinedValues);
			SourceStringService.FormatText(ref source);
			context.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
		}
	}


	static string GenerateSource(SemanticValues value)
	{
		var namespaceLine = IsGlobalNamespace(value.ClassInformation)
			? string.Empty
			: $"namespace {value.ClassInformation.ContainingNamespace};";

		var sb = new StringBuilder(
			/* language=C#-test */
			//lang=csharp
			$$"""
			  // <auto-generated>
			  // See: CommunityToolkit.Maui.SourceGenerators.Internal.BindablePropertyAttributeSourceGenerator

			  #pragma warning disable
			  #nullable enable

			  {{namespaceLine}}

			  {{value.ClassInformation.DeclaredAccessibility}} partial class {{value.ClassInformation.ClassName}}
			  {

			  """);

		foreach (var info in value.BindableProperties)
		{
			GenerateBindableProperty(ref sb, info);
			GenerateProperty(ref sb, info);
		}

		sb.AppendLine().Append('}');
		return sb.ToString();

		static void GenerateBindableProperty(ref readonly StringBuilder sb, in BindablePropertyModel info)
		{
			// Sanitize the Return Type because Nullable Reference Types cannot be used in the `typeof()` operator
			var nonNullableReturnType = ConvertToNonNullableTypeSymbol(info.ReturnType);
			var sanitizedPropertyName = IsDotnetKeyword(info.PropertyName) ? "@" + info.PropertyName : info.PropertyName;

			/*
			// The code below creates the following XML Tag:
			/// <summary>
			/// Backing BindableProperty for the <see cref="PropertyName"/> property.
			/// </summary>
			*/
			sb.AppendLine("/// <summary>")
				.AppendLine($"/// Backing BindableProperty for the <see cref=\"{sanitizedPropertyName}\"/> property.")
				.AppendLine("/// </summary>");

			/*
			// The code below creates the following BindableProperty:
			//
			// public static readonly BindableProperty TextProperty = BindableProperty.Create(...);
			*/
			sb.AppendLine($"public {info.NewKeywordText}static readonly {bpFullName} {info.BindablePropertyName} = ")
				.Append($"{bpFullName}.Create(")
				.Append($"\"{sanitizedPropertyName}\", ")
				.Append($"typeof({nonNullableReturnType}), ")
				.Append($"typeof({info.DeclaringType}), ")
				.Append($"{info.DefaultValue}, ")
				.Append($"{info.DefaultBindingMode}, ")
				.Append($"{info.ValidateValueMethodName}, ")
				.Append($"{info.PropertyChangedMethodName}, ")
				.Append($"{info.PropertyChangingMethodName}, ")
				.Append($"{info.CoerceValueMethodName}, ")
				.Append($"{info.DefaultValueCreatorMethodName}")
				.Append(");");

			sb.AppendLine().AppendLine();
		}

		static void GenerateProperty(ref readonly StringBuilder sb, in BindablePropertyModel info)
		{
			// The code below creates the following Property:
			//
			//	public partial string Text
			//	{
			//		get => (string)GetValue(TextProperty);
			//		set => SetValue(TextProperty, value);
			//	}
			//
			var sanitizedPropertyName = IsDotnetKeyword(info.PropertyName) ? "@" + info.PropertyName : info.PropertyName;

			sb.AppendLine($"public {info.NewKeywordText}partial {info.ReturnType} {sanitizedPropertyName}")
				.AppendLine("{")
				.Append("get => (")
				.Append(info.ReturnType)
				.Append(")GetValue(")
				.AppendLine($"{info.BindablePropertyName});")
				.Append("set => SetValue(")
				.AppendLine($"{info.BindablePropertyName}, value);")
				.AppendLine("}");
		}
	}

	static SemanticValues SemanticTransform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
	{
		var propertyDeclarationSyntax = Unsafe.As<PropertyDeclarationSyntax>(context.TargetNode);
		var semanticModel = context.SemanticModel;
		var propertySymbol = (IPropertySymbol?)ModelExtensions.GetDeclaredSymbol(semanticModel, propertyDeclarationSyntax, cancellationToken);

		if (propertySymbol is null)
		{
			return emptySemanticValues;
		}

		var @namespace = propertySymbol.ContainingNamespace.ToDisplayString();
		var className = propertySymbol.ContainingType.Name;
		var classAccessibility = propertySymbol.ContainingSymbol.DeclaredAccessibility.ToString().ToLower();
		var returnType = propertySymbol.Type;

		var propertyInfo = new ClassInformation(className, classAccessibility, @namespace);

		var bindablePropertyModels = new List<BindablePropertyModel>(context.Attributes.Length);

		var doesContainNewKeyword = propertyDeclarationSyntax.Modifiers.Any(static x => x.IsKind(SyntaxKind.NewKeyword));

		var attributeData = context.Attributes[0];
		bindablePropertyModels.Add(CreateBindablePropertyModel(attributeData, propertySymbol.ContainingType, propertySymbol.Name, returnType, doesContainNewKeyword));

		return new(propertyInfo, bindablePropertyModels.ToImmutableArray());
	}

	static BindablePropertyModel CreateBindablePropertyModel(in AttributeData attributeData, in INamedTypeSymbol declaringType, in string propertyName, in ITypeSymbol returnType, in bool doesContainNewKeyword)
	{
		if (attributeData.AttributeClass is null)
		{
			throw new ArgumentException($"{nameof(attributeData.AttributeClass)} Cannot Be Null", nameof(attributeData.AttributeClass));
		}

		var defaultValue = attributeData.GetNamedTypeArgumentsAttributeValueByNameAsCastedString(nameof(BindablePropertyModel.DefaultValue));
		var coerceValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.CoerceValueMethodName));
		var defaultBindingMode = attributeData.GetNamedTypeArgumentsAttributeValueByNameAsCastedString(nameof(BindablePropertyModel.DefaultBindingMode), "Microsoft.Maui.Controls.BindingMode.OneWay");
		var defaultValueCreatorMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.DefaultValueCreatorMethodName));
		var propertyChangedMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.PropertyChangedMethodName));
		var propertyChangingMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.PropertyChangingMethodName));
		var validateValueMethodName = attributeData.GetNamedMethodGroupArgumentsAttributeValueByNameAsString(nameof(BindablePropertyModel.ValidateValueMethodName));
		var newKeywordText = doesContainNewKeyword ? "new " : string.Empty;

		return new BindablePropertyModel(propertyName, returnType, declaringType, defaultValue, defaultBindingMode, validateValueMethodName, propertyChangedMethodName, propertyChangingMethodName, coerceValueMethodName, defaultValueCreatorMethodName, newKeywordText);
	}

	static ITypeSymbol ConvertToNonNullableTypeSymbol(in ITypeSymbol typeSymbol)
	{
		// Check for Nullable<T>
		if (typeSymbol is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T })
		{
			return typeSymbol;
		}

		// Check for Nullable Reference Type
		if (typeSymbol.NullableAnnotation is NullableAnnotation.Annotated)
		{
			// For reference types, NullableAnnotation.None indicates non-nullable.
			return typeSymbol.WithNullableAnnotation(NullableAnnotation.None);
		}

		return typeSymbol;
	}

	static bool IsNonEmptyPropertyDeclarationSyntax(SyntaxNode node, CancellationToken cancellationToken)
	{
		cancellationToken.ThrowIfCancellationRequested();

		return node is PropertyDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	static bool IsDotnetKeyword(in string name) => SyntaxFacts.GetKeywordKind(name) is not SyntaxKind.None;

	static bool IsGlobalNamespace(in ClassInformation classInformation)
	{
		if (classInformation.ContainingNamespace is "<global namespace>")
		{
			return true;
		}
		return false;
	}
}